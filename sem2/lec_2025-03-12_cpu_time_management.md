
ОСи, лекция 12.03.2025
тээк, че то вас все-равно мало. Ну щас давайте мы сделаем операцию, на которую вы жаловались у господина Андреева.
*Закрывает дверь на ключ и отмечает всех по пропускам.*
26 человеек.. Теперь открываем дверь
*за дверью пусто*
ладно, не очень-то надо
Не могу сказать, что успех превзошел ожидания. Небольшой лайфхак, если вам очень надо поговорить, вы в перерыве можете свалить и на вашей явке это не скажется.

Мы с вами разбирали два типа задач, теперь их три. Большая часть задач, с которой вы будете иметь дело большую часть карьеры, это либо системы реального времени, либо системы, которые обрабатывают запросы пользователей, людей. Люди с одной стороны нервничают, когда приложение лагает, но с другой стороны, если оно будет это делать редко или по понятным причинам для пользователя, то оно может быть и терпимо. Второе соображение, немножко более странное состоит в том, что управление временем цп в системе реального времени немного напоминает раздачу продуктов по талонам, которую я немного застал. Причем по талонам продавали даже водку, и столько водки, сколько продавали, далеко не все могли пить. В некотором роде это проблема фрагментации. Если вы обеспечиваете гарантии, вы должны закладывать приложению больше ресурсов, чем оно может использовать. Когда вы оптимизируете среднее время реакции, во-первых это намного проще, чем гарантировать время, во-вторых это время реакции гораздо меньше, чем время, которое вы могли бы гарантировать на той же системе на том же железе. Делать очень малое время реакции очень дорого, а то, что выдаст система реального времени пользователю гораздо хуже.

Система реального времени навязывает статическое распределение приоритетов, то есть взять все наши нити и тем, которым надо самое маленькое время реакции, приоритет выкрутить. Во время реакции низкоприоритетной нити входит не только ее собственное время реакции и латентность системы, но и все время, которое могут сожрать более высокоприоритетные нити. 

Вам в параллелизме еще будут рассказывать про системы реального времени, так что, возможно, это будет интересно и немного другая перспектива.

Тем не менее, реалтайм это с одной стороны важно, с другой стороны большинство из вас с ним скорее всего не столкнется. Большая часть из вас будет работать с тем, что мы называем системой разделенного времени. И оптимзиировать среднее время реакции. Оно зависит от довольно большого числа параметров.

В системах реального времени вы контролируете всю смесь приложений и вынуждены так или иначе им доверять.

Система разделенного времени выглядит у нас так, как она могла бы выглядеть в 70-е 80-е годы. И не только вы не можете доверять приложениям других пользователей, вы даже своим приложениям доверять не можете, потому что они в процессе отладки. Второй тезис немного странный, вы не можете позволить людям управлять приоритетами. Если позволить всем пользователям устанавливать приоритет процессов, то все поставят себе самый высокий приоритет. Это напоминает страничную подкачку.
Соответственно должна управлять приоритетами система. Спрашивается загадка, а как она будет ими управлять. Решение нашли в 70-е годы, нашли его методом тыка и оно оказалось настолько простым, что даже в моей книжке излагаются довольно длинные объяснения, почему оно вот так работает. После того, как книжка вышла из печати, до меня дошло, что объяснение совсем простое.


Смотрите, что нить должна сделать, чтобы сказать системе, что она ждет событие? Она должна заблокироваться на источнике события. Соответственно нити, которые не находятся в состоянии running не вносят вклад во время реакции. 
Поэтому у систем разделенного времени планировщики устроены очень просто - повышают приоритет тем нитям, которые сидят в заблокированном состоянии. А тем нитям, которые снимают по кванту времени с процессора, по системному таймеру, понижают. Если нить снимают с процессора по кванту времени, ей начисляют штраф. Этот штраф линейно понижает уровень приоритета. Накапливается он довольно быстро. Если нить не снимается по кванту времени, а снимается с процессора сама, то этот штраф снимают и у неё приоритет возвращается до исходного уровня. Бывают всякие надстройки над этим. У виндовса была такая фича, foreground priority boost. Она задирала приоритет приложению, на котором сейчас стоит фокус ввода. Если нить приложения висит в состоянии блокед, мы можем поднимать ей приоритет совершенно бесплатно. Вот эта очень, так сказать, рабоче-крестьянская схема. Тем не менее от неё со временем ушли. Примерно к 20-му году от неё отказались, больше полувека эти динамические планировщики использовались. Парадокс в том, что люди очень рады были такими планировщиками пользоваться. Тем не менее, действительно книжек, в том числе классических, даже в Таненбауме обоснование этой схемы является довольно заумным. На экзамене я буду требовать от вас такого рассказа.
Третий тип - 
Пакетные задания. Это в том числе майнинг биткоинов, машинное обучение. Поэтому когда запускают вычислялку пи, многие это не замечают.

Тут есть еще одна загогулина. Помните, когда мы изучали мутексы, мы затронули довольно странную тему про протокол и инверсию приоритета. От неё должны сильнее всего страдать системы со статическим приоритетом.

Представим себе, что у нас есть две нити с разными приоритетами. Одна реалтаймовая а другая сидит в классе планирования разделенного времени. У реалтаймовых нитей приоритет должен быть выше, чем у разделенного времени. Эти две нити как-то взаимодействуют, у них есть общий ресурс и он защищен мутексом. Защищен и что? Пока ничего страшного. 
А теперь представим себе, что нить разделенного времени мутекс захватила. Пришла нить реального времени, пытается захватить мутекс, а он занят. Реалтаймовая нить на мутексе засыпает, процессор освобождает, нить разделенного продолжает  работать. Все хорошо. 
Представим, что в системе есть еще одна нить реального времени. И у неё приоритет выше, чем у нити разделенного времени. В результате этого нить разделенного времени работает долго, реалтаймовая нить спит на мутексе долго, и просыпает свое гарантированное время реакции. Поэтому в позиксных мутексах есть два протокола - наследвоание приоритета и потолок приоритета.
Наследование - когда нить держит мутекс, её приоритет становится самым высоким среди всех нитей, у которых есть этот мутекс. 
Потолок приоритета - там добавляется дополнительный атрибут мутекса, потолок. Потому что в юниксе приоритеты считаются вниз. Соответственно потолок приоритета - уровень приоритета, такой, что у нити, которая держит мутекс, приоритет будет не ниже этого потолка. А если она имела более высокий приоритет, она может остаться, как была.
На самом деле оба решения годятся, чтобы закостылить проблему, но не решить. 
Представим, что эта нить разделенного времени заснула на чем-то еще, пока держала мутекс. И куда крестьянину податься, непонятно.

без judgement до того уровня, до которого мы дошли, вы дальше продвинуться не сможете.

Мы затронули тему инверсии приоритета. Бабочковая диаграмма, кооперативная, вытесняющая, это мы проходили, опять бабочка, приоритеты. У реального времени используется статический приоритет.


Разделенное время хорошо работало, когда вся система в целом принадлежала одной организации. Дальше, когда начались попытки продавать машинное время, (первые попытки были для пакетных задач, когда вы продали два часа процессорного времени и вам не важно, сколько реального времени она сожрет).
Когда вы продаете среднее время реакции, как это делают классические облака, возникает забавный конфликт интересов. 
Вы покупаете машину, на ней вы покупаете VPS или виртуальный сайт на apache. И там работает бэкэнд вашего сайта. Вообще говоря, чем больше процессора вы можете сожрать, вы можете монетизировать это. Можно нанять разработчиков подешевле, которые напишут вам неоптимизированное приложение. И оно будет жрать процессор. Можно нанять хороших разработчиков, которые напишут приложение с богатой функциональностью. И оно тоже будет жрать процессор. А можно нагнать побольше трафика. И он тоже будет жрать процессор. То есть есть три прямых денежных мотива сожрать побольше процессора. А дальше остальные клиенты, когда у них сожрали процессор, начинают спрашивать, а за что мы деньги платили? А дальше начинается самый интересный вопрос, а за что реально вы деньги платите? Потому что вам дадут два часа процессора, ночью в воскресенье, а все остальное время ваше приложение не работает.
Этот вопрос стали обдумывать, начали еще в конце восьмидесятых, полезные варианты обдумывания появились в конце девяностых.

Справедливое планирование. На самом деле справедливости в нем не очень много, но идея в чем. Просто процессорное время вас не интересует, вас интересует, чтобы это время было как-то равномерно распределено по суткам. И из этой постановки задачи справедливые планировщики и пляшут.
Вводится странное понятие, которое называется квант справедливости. Он длится порядка секунды, хотя иногда чуть больше, десять секунд. Дальше у системы есть группы процессов, как они выделяются, отдельная песня. В линуксе они называются сигруппами. Кстати, те, кто ходил на кибернетис, слышали какие-то странные слова в логах и в точках монтирования, там сигруппы появляются.
У каждой сигруппы есть какие-то попугаи, в которых написана доля времени, которое она может сожрать в течение кванта справедливости.
Дальше планировщик смотрит, в каких сигруппах есть процессы, которые еще не сожрали свою квоту попугаев в кванте справедливости. Потом кончается квант справедливости, он все это забывает и начинает с начала.
вопрос: то есть на один квант справедливости одна сигруппа.
ответ: нет, наоборот. Если у вас есть двадцать челвоек, которые купили на этой машине процессорное время, у вас есть двадцать сигрупп.
Квант - это время, в течение которого обеспечена справедливость, квота - это доля от кванта, которую сигруппа может сожрать.


Оба планировщика, которые мы проходили раньше, и статический, и динамический, и юниксный, и традиционный, работают за константное время, ведь все планирование происходит глядя на состояние очередей приоритетов. То есть стоимость работы планировщика вообще говоря не зависит от числа процессов. Но у справедливого планировщика это не так. Стоимость работы справедливого планировщика зависит от того, сколько у вас сигрупп. Нитей в каждой сигруппе. Стоимость растет за логарифм от этого количества нитей. Ну и, кстати, всякие контейнеры этим активно пользуются. На самом деле сигруппы это чуть более интересное понятие, вы можете задать квоту процессора, количество ОЗУ и пропускную способность ввода-вывода на всю сигруппу. Обычно квотируют память и процессорное время, причем время именно по такой семантике. Справедливые планировщики, в однопользовательской системе польза от них неочевидна, а во всяких облаках все это по полной программе начинается.
Современному человеку.. Ну, человеку может и не надо, а вот айтишнику точно надо про них знать. Не знать про них даже хуже, чем не знать про телекоммуникации. В некотором роде справедливые планировщики - тема для исследования, потому что то, что щас напридумывали, оно в некотором роде не очень хорошо.
Ну и вот, на этой оптимистической ноте мы планирование процессорного времени закроем.
Щас у меня немножко глухая ситуация, потому что у меня нет нормальной презентации про то, что я хочу рассказывтаь. Однако тема важная, и называется она - Ввод-вывод.

Платформы-то мы с вами наизучали, лекции-то вам читал Назаров и че он вам рассказывал про ввод-вывод.
По учебному плану вы обязаны были с этим вводом-выводом столкнуться на практике и Назаров вам там в плане лекций что-то рассказывал.

Тут история получается такая, что если вы ставить двойку, преподаватель, то вы ставите оценку самому себе. В данном случае если вы не знаете ввод-вывод, то я не самому себе ставлю двойку.

Вы можете в PCшку воткнуть терминал. Для этого вам надо на одной PCшке открыть терминал, эмулятор терминала, и одна из них будет терминалом, а другая - терминальным сервером.

Например, у последовательных портов, UARTов, есть вариант с буфером. С одной стороны, чтобы у устройства внутри был массивчик, ему надо припаять соответствующее число регистров. У последовательных портов бывает внутри действительно буфер. И можно сказать, что ты меня не дергая на каждый байтик, а вот когда буфер заполнится или дойдет до половины, шли прерывание.

Какое устройство передает много данных?
Камера, видеокарта? Жесткий диск.
Они работают пакетиками.

У сетевых карт должны быть какие-нибудь статусные регистры. В платформах мы разбирали только отображенный на память ввод-вывод. Однако у интела есть команды IN и OUT, похожие на load и store. У cdm8 был битик, за программой мы обращаемся или за данными. Если гарвардский режим, мы можем обращаться за памятью или за данными. У интела есть третий выход, который говорит, что я обращаюсь не за данными и не за программой а за вводом-выводом. На самом деле не так важно, отображенный на память или нет, у некоторых процессорах нет таких команд ввода-вывода. 
Другие процессоры, которые вы, наверное, живьем не увидите, у них в командах load и store есть битики, 2 или 4 можно из них использовать. И load и store вы можете делать в какие-то банки памяти, которые вообще не имеют отношение к основной памяти. Тем не менее вот, отображенный на память ввод-вывод.
Прежде чем устройство будет пользоваться DMA, вы обязаны ему сказать, куда ты этот DMA будешь делать. И эти регистры должны быть отображенными на память.

Вы должны устройству говорить какие-то сложные мысли и быть уверены, что устройство вас правильно поймет. Причем у некоторых устройств есть стандарты с разным статусом, например у PCшки был стандарт контроллеров USB 2.0. Точнее их тоже было два, но использовались только интеловские. Контроллеры USB 3.0 интел не стал делать референтную реализацию, и стали лепить их все, кому не лень, лепить как попало.


Мы приходим к понятию драйвера. У вас много устройств, похожих по функциям, но разнородных по интерфейсам. Даже если у них одни и те же порты ввода-вывода, то семантика в этих портах может быть немного разная. Понятие драйвера мы с вами произносили в прошлом семестре, и в общем-то понятно, зачем оно нужно. Драйвер - некий программный код, который предоставляет некоторый стандартизованный интерфейс, который позволяет системе работать с устройствами, которые в неё пожелали воткнуть. Дальше идет немножко странная политическая борьба. В чем она состоит. С одной стороны если разработчики ОС будут сами писать драйверы под все железо, которое есть на рынке, они опухнут. Логично, чтобы драйверы писал разработчик железа. Он тоже хочет сэкономить деньги. Поэтому он хочет писать драйверы под как можно меньшее число систем. Если никто не напишет драйвера, то ОС с этим устройством работать не будет. Это довольно простой вариант. И, пользуясь этим эффектом, виндовс держала монополию очень долго. Разработчики дешевого оборудования говорили, что раз линуксов 10%, драйверы мы на них делать не будем.

Крупные производители по типу NVIDIA что-то делают. Но там проблема в том, что они свои исходники не открывают. Есть closed-source драйвер под линукс, есть open-source, который не очень-то работает. Этот фактор - один из главных факторов отбора ОС. Те ОС, которые теряют популярность, под них перестают писать драйвера, и на новом оборудовании вы их можете запустить только на виртуалках. Этот момент довольно важный и вы уже достаточно взросленькие, чтобы о таких вещах задумываться. 
Второй момент - а какой же интерфейс драйвер должен предоставлять. 
Я с вами перекличку не проводил, но давайте проведем, какие устройства могут быть подключены к комьпьютеру.
Хранилище? Да, хорошо. Монитор? Это не устройство с точки зрения компьютера. К компьютеру подключается видеоадаптер. Кстати, видеокарты умеют в наше время еще одну вещь, CUDA вычислитель. Забавная эволюция, и поскольку я эту эволюцию наблюдал с самого её начала, есть много что рассказать.
Наушник - это АЦП - аналогово-цифровой преобразователь. Мышки, тачпады. Принтеры. Сволочи, сложные и дорогие, но без них в наше время тяжело. Камеры.

Какие типы файликов dev соответствуют драйверам? Символьные и блочные устройства.

Вот у нас есть звуковая карта. Как из неё сделать символьное устройство? Аналоговый сигнал аудиокарта умеет дискретезировать. Она реально принимает и передает потоки байтов. 

Диапазон частот в звуковом сигнале определяется частотой дискретизации. Есть телефонная частота 8 кгц, а есть CD quality 44 кгц. Есть всякие извращения наподобие 48 кгц. Звуковые карты понимают больше. 
Бывает 8 бит на сэмпл и 16 бит на сэмпл. Даже 16 битные АЦП младшие биты в основном цифруют тепловые шумы старших разрядов. 
Вопрос: а зачем тогда 24 биты на сэмпл?
Ответ: на самом деле честный 24 битный ЦАП надо охлаждать жидким азотом. Иначе младший байт этого ЦАП будет бесполезен, он будет цифровать тепловые шумы. 
Прежде чем вы начнете писать байтовый поток, вам надо звуковой карте все это сказать.


Ну в общем вот тем не менее да.
ioctl может повлиять на то, как устройство интерпретирует поток данных, но само потоком данных не является. В случае звука это частота дискретизации.
На самом деле тут странная вещь, в windows порядка ста типов драйверов. В линуксе тип один, но в зависимости от типа устройства могут быть разные команды. Кто ставил линукс на десктопы, там есть два типа драйверов, pulsaudio и castle (вроде). Это два разных стандарта команд для работы со звуком. Поскольку куча приложений работают с одним или другим, то до сих пор тянется поддержка обоих типов драйверов. На самом деле это тоже не сильно хорошо, и в общем-то всю эту историю с терминалом, я упоминал интересную фразу, это провал юниксовой идеологии "все файл". Часть усторйства функциями файла покрывается, а другая чатсь - не покрывается. И вот расширять эту вещь при помощи ioctl команд, пока было мало типов устройств, оно казалось разумным, сейчас оно уже разумным не кажется, тем не менее, в линуксе как-то так и живут. Самое интересное про интерфейс драйвера мы еще даже не начали обусждать.
Очевидно, что драйвер должен быть отдельным потоком, потому что к нему обращаются приложения, которые сами являются потоками. Драйверы являются приложениями реального времени. Если они не успеют обработать события устройства, они его потеряют. Мы с вами познакомились с понятием потока, и на следующей лекции мы с вами попытаемся обсудить, что такое драйвер с точки зрения многопоточности. Бзынька не будет.