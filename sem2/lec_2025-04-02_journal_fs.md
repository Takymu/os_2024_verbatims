
Интерактивная лекция по ОСям. 02.04.2025

Функции файловой системы:
создание иерархии ресурсов
оптимизация доступа к данным
борьба с фрагментацией памяти

Типы файлов:
директории
регулярные файлы
символьные устройства
ссылки
блочные устройства (диски)
именованные семафоры
сокеты
тд

Про права доступа говорил (владелец-группа владельца-остальные) r/w/x

Про линки
симлинк - указание на путь до файла
хардлинк - указание на иноду
хардлинк перестанет работать при перезагрузке сервака

База уже прошла, давайте подумаем
сколько файловых систем может быть на сервере? ответ: много
у нас есть разные файловые системы, как бы мы в ос сделали работу с файловыми системами? ответ: интерфейс нужен какой-то (виртуальная файловая система). под вфс может быть что угодно (любая файловая система). поэтому можно делать много файловых систем на серваке

Смотрим корень мака Хаверко:
bin - понятно (папка с бинарями)
proc - отдельная файловая система в корне
dev - всякие устройства символьные и блочные
etc - папка с конфигурациями
home - ведет в папочку с пользователями
sbin - непонятный отголосок какой-то bin'а
tmp - всякая времяночка от ос
usr - аналоги корневых папок под юзеров
lib - библиотечки
lost+found - файлы, которые вовремя не засимкались
mnt - точка монтирования

"Я не хочу углублять вас сильно, я вам рассказываю так, как будто вы пользователь сервачка и всё"

По структуре корня пробежались, теперь подумаем про то, как можно располагать файлы на диске. Файловая система - штука, которая абстрагирует нас от диска. Над ней интерфейс - виртуальная файловая система. Вернемся к вопросу. Ответ: принято использовать индексный доступ через табличку инодов. стандартный подход, хорошо себя ведёт обычно

Вспомнили мы, что такое инода, а что там хранится вообще? Ответ: всё (права, владелец, короче всё, что через ls)
Количество инодов ограничено (через df -h можно глянуть, что как подмонтировано)

Есть диск. мы его монтируем как устройство, появляется точка монтирования. изначально она без файловой системы (фс), надо туда фс установить. Это не говоря о дисках. О дисках мб расскажет еще сегодня

"Соляра - это плохо. Линукс, зачем соляра?"
- Давайте макось
- Макось еще хуже

Про иноды: колво ограничено. что будет, когда они закончатся? нельзя файлы создать. выход: пока совсем не закончились, удалить какие-нибудт файлы, иноды можно переиспользовать. надо следить за тем, чтоб совсем не закончились инодики, иначе рефармотировать диск придется
Где хранить метаданные (колво инодов, их табличка)? принято в каждой группе суперблока хранить их. чтобы если один суперблок попортим, то с другого читать. если начнутся проблемы с файловой системой (когда места дофига, но вылезают непонятные ошибки). fs^C полечит битые блоки и что-то такое.

"Это не то, это неинтересно"

Быстренько пробежимся по журнальным фс. Что это? Короче жфс перед тем как записать данные на диск ведет некий журнал (коммит лог в базах данных называется). записывает в журнал, что должна записать чтото на диск. произошел сбой, сервер вырубился, данные из оперативки пропали. если бы журнала не было, мы бы сказали, что данные потерялись. прикиньте, вы перевели сто тыщ и в этот момент электричество вырубили? жфс увидит, что надо было это записать и запишет, когда осиретевшую запись, на диск не записанную, найдет при запуске сервака заново
В чём еще плюс жфс помимо надеждности? Можем больше обработать запросов, потому что меньше обращений к диску, потому что работаем-то с журнальчиком. чтото в журнале накопилось - идем пишем на диск. появляется запись в журнале, что мы записали на диск
Как поймет ос, где лежит таблица инодов? короче на диске как располагается всё. есть бутсектор, который запускает ос. она лезет на точки монтирования и ищет гдето в начале суперблок. если не может запуститься то говорит иди почини суперблок (которй в начале диска)

"Виндовую фс не хочу вам рассказывать. Винда - зло"


Немного накидаю вам про сетевые фс. Два основных типа: нфс (нетворк файл систем - есть некий сервачок с кучей места - есть протокол между клиентом и сервером - мы монтируем это к себе - на один большой сервер можно наконнектить много чего) и ...

Транзакция - набор операций либо выполняется весь, либо не выполняется вовсе. В жфс тоже транзакция, чтобы не было такого, что сказали пользователю, что данные приняли, а сами их потеряли

м-тейбл - табличка маунтов фс

вопрос группе Хаверко: допустим, работает какой-то приклад, который монтируем при старте. вдруг его решили рестартнуть. на старте читает конфигурацию и получает пермишн денайд на какой-то файл. раньше запускалось - было ок. пользователь не менялся. группа тоже не менялась. фс тоже не менялась. давайте думать быстенько. смотрим файл конфигураций. там три 7 и всё равно пермишн денайд, который связан с правами. файл никак не менялся. самое ближнее к файлу - директория. у нас тупо нет прав на директорию. чтобы что-то прочитать в директории, нужны права экзикьют. при этом если есть права на рид, то читать можно

Вспоминаем про сетюид бит. позволяет исполнять программу с правами владельца. это то, что нужно запускать под рутом, если мы рутом не являемся

Поговорим про диски. Сколько в жестком диске магнитов? Зависит от диска. там древняя бурда (головки, диски у хдд). Погнали гуглить raid. Короче люди не балбесы и решили придумать способы организации номральные чтобы не терять данные. RAID 0 раскидывает части на два диска. При выходе из строя одного диска второй остается. По чексуммам одного диска можем проверить другой диск. RAID 1 - зеркалирование (один в один данные раскидывает). RAID 10 - соединение RAID 0  и RAID 1. Зеркалирует внутри своего диска блоки дисков и раскидывает между дисками. RAID 5 - Patiry - чексуммы блоков или типа того. RAID 6 что-то такое же. Еще есть какая-то странная четверка (RAID 4). если не будем заниматься серверами руками, то кто-нибудь за нас рейд соберет

Про базы данных просят. Базёнки. Реляционные базы данных используют реляционную алгебру. Весь sql базируется на реляционной алгебре. Когда изобретали, хотели формально доказать, а так знать ра не надо, просто ра доказывает, что реляционная бд работает. Основное, что относится к реляционкам - ACID. A - атомарность (транзакции) C - консистентность (свойство которое гласит что у нас бд из одного непротиворечивого состояния переходит  в другое. тип то что мы сохраняем никак изза параллельности не поменяется) I - изоляция (самое проблемное свойство. самые интересные проблемы. транзакции идут параллеьно. результат одной транзакции никак не влияет на результат работы другой транзакции) D - дюрабилити (? если чтото записали то оно останется)

Методики для запоминания. Начал работать на втором курсе. заинтересовался еще в школе прогой. когда изучаем материал проверяем поняли ли предложение которое прочитали. задаем себе неудобные вопросы. в духе "а как оно устроено". тогда всё ты на порядок выше сверстников коллег и тд.


что на третьем и четвертом курсе будет. третий курс - начнем заниматься всякой хренью. из интересного проектирование по. если чтото знали то курс бесполезный если ничего не знали то ок. остальные предметы вообще не помнит :) пошел смотреть в расписание что было. куда не стоит идти? что по предметам не выбирать. компьютерное моделирование бесполезное. хранение и обработка инфы - над курсом надругались, полная фигня. пак понятно. методы глубокого обучения не подскажет ненавидит все что с этим связано. проектирование интерфейсов халява - рисовать надо. биоинформатика - легкая оценка. оптимизация джавапрограмм - полезно для джавалюбителей. разработка на пайтоне с иртегом. питон только в мл и в ооо рога и копыта. 
на четвертом курсе один номральный курс - распределенные алгоритмы.
слава ушел из маги, так бы сейчас учился на первом курсе.
с какой скоростью он печатает? достаточно быстро. час на изучение книги.
чтото техническое. есть простая книга (для даунов) - хэд фёрст (серия книг). есть паттерны проектирования и еще всякое. легкая литература. придем на курс к мигинскому и скажем чтоо все знаем. на работе применяется. на паке изобретаем своё это оно и есть (ну ладно мы пишем костыли). "чистый код. анализ и рефакторинг". танненбаум "сети" чуть ли не с физики (канальный уровень и до л7, крутая книга). go - норм тема. прикольный язык. мб будет факультатив по го от славы для третьего курса. базовый синтаксис языка по статьям в хабре понимается. штук 30 ключевых слов. а вот как планирование потоков работает и память аллоцируется надо уже искать. конкретной книги нет. но есть книга "100 ошибок го". крутая. документацию смотреть
мы не должны бояться большого кода. смотреть исходники это нормально. искать в достоверных источниках. стек оверфлоу не является достоверным источником. документация является