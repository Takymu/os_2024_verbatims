ОСи, лекция 05.03.2025

Ну че, коллеги, типа звонок, давайте учиться. Мы с вами прошли, что такое дедлоки и как с ними бороться. На самом деле упражнений с локами у нас не так много, одно из них это связный список.

С одной стороны вы можете одной и той же структурой атрибутов мутекса создавать много мутексов, с другой стороны при изменении этих атрибутов в структуре сами мутексы не поменяются

ERROR_CHECK mutex считается дорогой, он применяется только при отладке.
Рекурсивные мутексы как и в джаве синхронайзд блоки могут быть рекурсивными.
Дефолтный тип может мапаться на какой-то из стандартных типов, в солярисе нормальный.
pshared мутекс доступен другим процессам, то есть используется для межпроцессного взаимодействия.

ROBUST NP - имеет смысл только для PSHARED, потому что если у вас нить убьется сигналом, то вместе с ней все нити убьются.

Если у вас подпроцесс помер какой-то нехорошей смертью, держа мутекс. Че делать? На самом деле делать сложно, проблем две, мало того, что у вас мутекс залочен, вы еще и не знаете, в каком состоянии находится ресурс, который этот мутекс защищал. ROBUST определяет интересную штуку называемую протокол. Протокол как быть с мутексом если процесс, который его держал, помер. ROBUST и STALLED делают разные вещи.

На самом деле упражнений у нас на это нет, потому что представив себе как вы пишете обычные упражнения, представить то, как все семинаристы опухнут, довольно легко.

STALLED остается залоченным навсегда. ROBUST стоит использовать, если вы знаете, как починить залоченный ресурс. 
Протокол, а че такое протокол, а, я уж сам забыл.

А, протокол это интересная тема, относится к странной теме, название которой я вам не назвал, под названием инверсия приоритетов.

Поговорим про инверсию приоритетов и как с ней можно бороться. Пропустим эту тему, хотя она немного интересная. Интересно, но нам оно запрещено. (какой-то он сегодня противоречивый, инвертировался)

Мы пойдем таким путем: эту лекцию добежим, я расскажу про примитивы синхронизации, а потом мы поговорим про приоритеты и про классы планирования и про то, что с этим бывает.

У нас есть две странных презентации, которые имеют номер семь, там conditional переменные и куча всего.

Итак, другие примтивы синхронизации. Они включаются в себя read/write локи. Это довольно простая и полезная штука, смысл которой мы можем понять, если вспомним определение критической секции. 
Есть два типа секций. При одном типе мы модифицируем данные. При другом можем не модифицировать, но нам надо, чтобы их не модифицировал никто еще. Если у нас много критических секций на чтение, то мы можем сделать два типа блокировок, на чтение и на запись. В прошлом семестре мы видели два точно таких же типа захватов файлов. Эту логику знали уже до того, как pthread придумали. read/write лок похож на мутекс. 
pthread_rwlock_t
у него тоже есть инициализатор и его рекомендуется дестроить.

блокировка на чтение. Она рекурсивная всегда, это гвоздями прибито, и она не монопольная - много нитей могут держать блокировки на чтение.
блокировка на запись монопольная, только одна нить может писать в один момент.

если вы модифицируете защищаемый ресурс, используйте блокировку на запись.

Более сложная концепция, на которой мы вынуждены остановиться практически - условные переменные.

Главная мысль, зачем была придумана условная переменная - производитель/потребитель.

Это могут быть две разные нити, которые могут обмениваться, так скажем, байтиками данных. Производитель эти байтики производит, а потребитель, так скажем, потребляет. Это может быть труба или клавиатура, на которой пользователь набирает что-то, а процесс ваш осознает.
Если мы просто сделаем байтик и защитим его семафором, возникает дурацкая проблема, каким образом потребитель узнает, что доступен следующий байт.

11 задача не принимается без 12. На мутексах задача производитель-потребитель по-человечески не решается. Вот один из способов, как ее решать по-человечески - это условные переменные.
Если вы покопаетесь внутри ядра солярис, вы увидите мутексы, которые реализованы через условные переменные. Вы можете в ядре солярис сишный код мутекса, но не можете найти сишный код условной переменной - она на ассемблере написана и может быть разной для разных архитектур. Условная переменная немного странная. Я надеюсь, я привлек ваше внимание. Создается она похожим образом на то, что мы проходили, довольно скучно.

Порядок инициализации похож, есть pthread_cond
две главные операции над ней - wait и signal.
У неё есть атрибут мутекса, который должен быть залочен. 

Парные функции сигнал. signal и broadcast. 
Если на условной переменной вейтятся много нитей, сигнал будит ровно одну из них, произвольную. broadcast пытается разбудить все нити, но поскольку только одна из них держит мутекс, проснется только она.
Жесткой связи между мутексом и условной переменной в солярисе нет. Но стандарт гласит, что если вы лочите условную переменную с разными мутексами, результат неизвестен. Второй вопрос, следует ли держать мутекс залоченым, когда вы делаете сигнал. Когда мы поймем, зачем же, черт побери, все это надо, мы поймем, что лучше все-таки держать мутекс залоченным, когда вы делаете сигнал.

Зачем это надо? Один из простых способов о ней мыслить - как о культурном способе сделать холостой цикл. Если вы хотите сделать холостой цикл, вы должны когда-то из него выходить, у вас есть какой-то предикат, по которому вы выходите.
Условная переменная предлагает выход из этой ситуауции. Есть у вас предикат или условие, чего вы на самом деле ждете. И вместо того, чтобы спинится на этом условии, вы проверяете, если оно вас не устраивает, вы садитесь в condition wait и спите. И поскольку вы вынуждены на нем спиниться, в вашей нити это условие поменяться не может. То есть его должен поменять кто-то внешний по отношению к вам, то есть другая нить. И кто-то, кто меняет условие, вам должен этот кто-то просигналить, "вставайте, граф, вас ждут великие дела". И одна из ситуаций, если графьев спит несколько, то первый хватает, а че делать остальным? Вторая ситуация, ошибка потерянного пробуждения. Вот этот предикат - это то, что вас интересует. Вы должны защитить ваш предикат мутексом и проверяете вы его под защитой мутекса, то есть предикат - это может быть что-то довольно сложное. И вы его проверяете. А если бы вы сидели в холостом цикле под этим мутексом, никто бы это условие не мог поменять. А так вы во-первых освобождаете мутекс, во-вторых не тратите процессорное время.

Первый вариант плохого исхода - если у вас несколько нитей спало и кто-то другой по какой-то дури сделал broadcast. Вы делаете этот цикл и когда вы выпали из условной переменной, вы обязаны проверить предикат снова. Потому что во-первых это может быть спулиос(?) wakeup, то есть вас могли разбудить сигналом и вы могли проснуться сами по себе. Хотя солярис мне поймать на этом не удавалось. спулиос wakeup я воспроизводить в солярисе так и не научился, это не значит, что он невозможен, по крайней мере стандартом он разрешен. 
Второй вариант, если вы просигналите условную переменную, а на этот момент никто не спал. Реализация может запомнить и разбудить как только вы попытаетесь уснуть. А может не запомнить, это будет ошибка потерянного пробуждения.

Ну и вот условная переменная, как я уже сказал, применяется в паре с мутексом, и всю эту семантику я вам уже формально рассказал. Мутекс должен защищать тот предикат, который вы проверяете. И не стоит защищать им что-то еще. То есть когда вы проверяете предикат, то потом вы хотите делать что-то другое, и желательно это защищать уже другим мутексом.

Ну и вот, применение условной переменной она применяется в задачах типа производитель-потребитель. Там есть задачи на печать по очереди. На мутексах эта задача, на самом деле я бы даже сказал, что на мутексах она корректно не решается. Вы можете сделать эту зацепляющуюся хреньку на трех мутексах, но возникает вопрос, как в неё попасть.
Условная переменная позволяет вам это сделать простым и естественным образом и у нас на это есть упражнение. 

Другая задача, которая сводится к разделяемому ресурсу. Проверьте, сколько это решение с cp -r заняло времени процессорного, и вы увидите, что создавать нитку на каждый каталог, это не очень плохая идея. Если я вас попрошу скопировать большое дерево каталогов, например исходники соляриса или ветку irtegov/accepted. Упереться очень легко, поскольку каталоги это тоже файлы. И чтобы программа не валилась, она должна ждать, пока у вас появятся ручки открытых файлов. Штатного способа это сделать нет, но имея условную переменную, вы можете это сделать. Если вы уперлись в лимит, вы должны сесть на условную переменную и ждать, пока вам просигналят, что у вас появились системные ресурсы. 
Задача в такой формулировке это не очень хорошая идея на тему того, как рекурсивно копировать файлы. По идее вы должны создать небольшое число нитей и раскидывать между ними работу. Никто этого пока не сделал.

Вот, эээ, вот ну и вот.
И еще одна тоже форма, на которую у нас есть задачи. Атомарный захват нескольких мутексов на условной переменной тоже можно сделать. Вы пытаетесь захватить мутексы, если у вас это получается, то ура, если не получается, то вы садитесь ждать, пока вам просигналят.

И еще один примитив синхронизации, который мы тоже должны пройти и на который у нас есть упражнение. Он называется семафор.

Попал! Так, где оно, где оно-оно-оно вот оно.

Одна из наиболее понятных для понимания причин пробуждения - в той нити, в которой вы спали, обработается сигнал.

Вопрос: Я находил оговорку, что разрешение произвольных пробуждений позволяет ускорить обработку кондишинал
Ответ: У вас один производитель, два потребителя. Производитель что-то произвел, будит обоих потребителей. Один потребитель проснулся и потребил, второй просыпается и обнаруживает, что потреблять-то и нечего.


Так, коллеги, я не знаю, я уже вроде говорил, спать на первой парте - это особая форма общественного вызова.

Вопрос: по поводу консультации..
Ответ: мы тут беседовали с нашей семинарской группой, похоже, я в этом семестре физически не смогу делать вторую пару семинарску весь семестр. Тем не менее, основная проблема, из-за которой люди сдают медленно, это то, что люди медленно отвечают на теоретические вопросы. Можно сделать дополнительную пару - консультацию. Мы попытаемся обсудить вопросы, которые вызывают затруднения. Поэтому можно например в эту субботу эту пару провести. 
- а эта суббота не считается праздничной?
- на самом деле да, в эту субботу нас не пустят. 

Семафоры мы проходили в прошлом семестре, на самом деле они больше известны как семафоры-счетчики. Они в немного странном месте, это не часть позикс библиотеки. Они находятся в разделе librt. 

Соответственно, семафоры и счетчики были заточены под межпроцессное взаимодействие. У них есть две забавные формы, неименованные семафоры и именованные. В процессно-разделяемой памяти вы размещаете какой-то объект. Вы делаете sem_init, и контракт здесь такой, что возвращается errno. У него есть атрибут, разделяемый между процессами или годится только для нитей. 
Семафоры тоже надо потом дестроить и соответственно вот.
Над семафором есть две операции, которые называются post и wait. Есть так называемый trywait, который похож на trylock, и я вам пытался также внедрить определение на категориальные вопросы. Как я вас учил определять его на категориальных вопросах?
Примитив синхронизации, который содержит некую флаговую переменную. (не определение) И операция post увеличивает флаговую переменную.

Кто может спать на семафоре?
Макс: я.
Я думаю, на том семафоре, который мы обсуждаем, вы не поместитесь. Семафор находится в плашке оперативной памяти, так что вы на этот семафор вряд ли поместитесь.

wait - вы вычитаете из семафора единицу, и если она у вас стала отрицательной, вы засыпаете, пока вам не сделают post.
В позиксе можно делать post и wait только на единичку, в джаве на произвольное значение. 

- Вы уже проходили джававские семафоры и счетчики? 
- Мы на мониторы смотрели
Мониторы - это совсем другая сказка.
Как я вам уже говорил, значение флаговой переменной может быть.. ну, как любым. Если это целочисленная переменная, вы рискуете её переполнить. В стандарте гарантируется только 16 бит. Полагаться на большое значение вы не можете.
Семантика может использовать семафор как разделяемый счетчик. Вы можете их таким образом использовать. 
sem_get_value возвращает значение флаговой переменной семафора, как в мане сказано. Она возвращает значение флаговой переменной семафора на какой-то момент времени - это оговорка, которая имеет значение в многопоточном программировании. Эта функция имеет смысл при отладке, в продакшн коде её быть не должно. Эта оговорка про какой-то момент времени такие примитивы сильно обесценивает.

Забавный пример - применение этой штуки для задачи производитель-потребитель. На двух семафорах решить её можно корректно. То есть семафор - это семантически полтора мутекса. Снятие правил на то, что post и wait делают в одной нити, позволяют манипулировать семафором в тех местах, где вы не можете использовать мутекс, например в обработчике сигналов. Или, например, в реалтаймовой нити, которой надо реагировать за фиксированное время, и если вы её усыпите, она ничего полезного не сделает.
Упражнений на реалтайм у нас нету, но в ядре такая проблема возникает при обработке прерываний. Вы там не можете использовать семафоры, можете использовать только post или trywait. Если вы усыпите обработчик прерывания, то вы усыпите какую-то нить, и вы даже не знаете, какую. Это совершенно не то, чего вы хотели бы. С сигналом та же самая петрушка.
Если вы эту нить усыпите, вы даже не будете знать, какая это нить, и масштабы этого бедствия трудно вообразимы. 
Второй тип семафоров, который мы проходим, это именованные семафоры. То есть у них имя, но оно не как у файла, оно имеет 14 байтов и не может содержать слэшей. В солярисе они создаются в папке tmp, в линуксе в какой-то другой папке, вроде dev/shlem (или что-то такое)
Это немного усложняет жизнь, если вы хотите создать семафор, вам надо сочинить уникальное имя для него.
Тут одна смешная деталь.. Две смешные детали.
Вы задаете ему имя и какие-то флаги, такие же, как у опена. С другой стороны, если такой семафор уже был, вам просто его возвращают. И вы можете работать с обычным семафором. Когда вы используете create и exclusive, и файловую маску прав доступа, и если у вас нет доступа на именованный семафор, то вам его не откроют. Если вы откроете его на чтение, вы можете только считывать его значение, что, как мы выяснили, не очень полезная операция. 
Кстати, при exec, не только при exit, но и при exec, семафоры закрываются. Уничтожение семафора - довольно интересная операция. Мы такую же шнягу видели на примере сокетов. Надо делать unlink. 
Дальше в принципе вся та же философская шняга, которую я вам пытался рассказать, только тут она не про удаление unix domain socketов.
Мы в рамках той же самой философии ownership, которую вам пытался внедрить Стененко, удалять семафоры должен тот, кто их создавал. Однако тут это не так страшно, если вы unlinkнете семафор, который уже все, кому надо, открыли, они будут продолжать работать с ним. Но снова открыть не смогут.
Соответственно ну мы и вот таким образом мы можем это делать.
У нас на них одно упражнение, именованные семафоры имеют смысл для взаимодействия между процесами, а не нитями. Мы затрагиваем тему межпроцессного взаимодействия довольно поверхностно.

Соответственно, че мы с вами изучили, у нас с вами еще довольно много времени. Мы в некотором роде с вами прошли, как это было, восемь классов прошел, и ни на одном не остановился. Так, че-то вы куда-то
- выйти
- а, хорошо.
Мы с вами на самом деле переключимся на теоретическую тему, которую я в прошлом семестре немножко скомкал, а в этом семестре
(на файловую систему parallels) блин как ты меня заколупал-то!
(кашлянувшему на первой парте) так, я, как человек хороший, пришел в масочке, а вы меня сидите и обкашливаете.

Если вы делаете ввод-вывод, вы делаете какой-то запрос, который к вам приходит по сети, вы его обрабатываете, потом овтечаете. Для обработки вам надо какие-то данные с диска прочитать.
Если мы хотим несколько запросов обрабатывать параллельно, то латентность у нас может даже понизиться на некоторых запросах, но зато вырастает пропускная способность.

В чем проблема у вас с сетевыми технологиями? Знаете, вот сетевые технологии, специальности в айти, в которых вы можете сказать, что меня в операционную систему не пускают, поэтому я знать её не буду. 
(обсуждение сетей, в ходе которого Иртег предсказуемо остался при своем мнении)
Тем не менее, одну болезнь я вижу, вместо того, чтобы идти за преподавателем, вы пытаетесь доказать, что вам неправильно учат.

Диаграмма бабочки, которую мы с вами в прошлом семестре видели. Нить может быть в состоянии running, blocking, ready. 

Возникает вопрос, если у вас есть много нитей в состоянии ready, в принципе вы можете посмотреть, команда top и еще многие команды выводят такую интересную метрику под названием load average. Если у вас загрузка процессора меньше ста процентов, то load average похож на единицу. Если загрузка процессора сто процентов, то у вас load average больше, и десятки нитей чего-то ждут, ждут возможности исполниться. Сегодня мне вот как раз сдавали этот несчастный прокси, и он процессорное ядро радостно захавал. 

В дальнейшей лекции я буду слова процесс и нить употреблять вперемежку, потому что объектом планирования у нас являются все-таки отдельные нити. По каким принципам отбирать процесс? Вопрос, на что это влияет. Кстати, это экскурс в еще одну тему, проекты. У вас есть как бы функциональные требования, то есть что должна делать ваша программа. Когда вы сдавали задачи на первом курсе, у вас были только функциональные требования и три нефункциональных - время, память и язык. А когда вы работаете с каким-то сетевым сервером, конечному пользователю довольно пофиг, сколько памяти оно сожрет, главное, чтобы оно влезло. Конечного пользователя интересует время реакции. Чуду подобен ум ребенка. Есть две разных ситуации, как вас волнует время реакции. Представим себе, что у вас приложение не интерактивное, а какой-нибудь самоуправлемый автомобиль или термостат. Вот он включает нагреватель, когда слишком холодно, и выключает, когда слишком жарко. Простенькая задача. Нам важно время реакции. Но какое время реакции нам важно? У термостата время реакции на разные события одинаковое, а у какого-нибудь автомобиля может быть разное.
Вот автомобиль едет-едет, и видит на дороге упавшее дерево. Поскольку это система машинного зрения, ей надо осознать, что вся картина, которую она видит, полностью поменялась. Сколько у него времени на реакцию? Мало. Это время определяется физическими параметрами управляемой системы. Если он не уложится в эти физические параметры, то он кого-нибудь убьет в худшем случае, в лучшем будет что-нибудь не то. Реальное время определяется приложением. 
Определение для критов, категориальные вопросы:
Приложение реального времени - это приложение, которое реагирует на внешние события не позднее, чем за фиксированное время. Система реального времени - система, в которой можно эти приложения запускать.

Если вы помните, была такая страна как советский союз, и последнее десятилетие его жизни характеризовалось таким явлением как талоны.

