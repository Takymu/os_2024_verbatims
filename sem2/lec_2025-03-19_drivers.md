Ilya_, [19.03.2025 15:56]
ОСи, лекция 19.03.2025

Так, ну, сегодня народу побольше, это дает некоторый повод для оптимизма

Ну че, коллеги, звонок был, звонок был. Мне поскольку не очень удобно стоять, но мне тяжело ваш перекрикивать. Так что прошу поиметь совесть в плане разговоров. Мы остановились на чем, я все-таки одну вещь недорассказал. 

Понятие драйвера. Мы с ним сталкивались в прошлом семестре. Потребность в драйвере возникает по двум причинам. Одна чисто технологическая - драйверы делают операции ввода-вывода. Что мы про них знаем?
С: они блокирующие
как раз обращения к драйверам они блокирующие, но операция обращения к драйверу сама по себе не ввод-вывод.
Что мы знаем про операции ввода-вывода? Может ли пользовательский процесс исполнить операцию ввода-вывода? Нет, это разрешено только ядру. На самом деле действительность немножко богаче, есть всякие битики io у интела, то есть на самом деле можно пользовательскому процессу разрешить ввод-вывод. ОС запрещает вам это делать поэтому она вынуждена это делать за вас. Поэтому драйвер это модуль ядра. На самом деле дальше мы увидим более интересный сценарий, драйвер может быть пользователським процессом, с которым вы разговариваете через интерфейсы ядра.
Самое веселое - устройство с прямым доступом к памяти. Имея доступ к такому устройству, как бы вы его не получили, вы можете записать данные куда угодно. То есть драйвер должен быть доверяемым модулем ядра.

Третье соображение, опять же, экономическое. Представим себе, что вы пишете какую-то программу. Если вы пишете её для своего компьютера 
КОЛЛЕГИ!!!
и не собираетесь продавать - полностью ваша проблема, какую периферию вы будете поддерживать.
Но если вы будете программу продавать - какое оборудование вы должны поддерживать? Если вы пишете для конкретного заказчика, вы делаете под конкретное оборудование и знаете это оборудование. А если вы продаете кому сможете, то вы не знаете, какой вам придет заказчик и с каким оборудованием. Вот получается, что когда вы пишете приложение, вы хотите поддерживать разное оборудование, не занимаясь разработкой драйверов под него. Кто-то должен эти драйверы разрабатывать. Начинается та хитрая экономика, драйверы пишут либо разработчики ОС либо разработчики железа. Наблюдать, как одни нагибают других писать драйверы, способствует некоторому разочарованию в человечестве.

Ilya_, [19.03.2025 15:56]
Драйвер - некий модуль, который делает некие операции над устройством. Эти операции он делает по запросу прикладной программы.
Когда мы пытались классифицировать устройства, я вам не рассказал, вот есть у нас устройства вроде диска, которые пока вы не попросили, никакие данные вам не предоставят. А есть устройства - источники событий. Они характеризуются тем, что они могут начать вам что-то рассказывать, когда никто их об этом не просил. Сетевой адаптер - данные приходят из сети, кто-то что-то захотел вам послать, и возможно вы что-то с этим должны сделать. 
К вам неожиданно приходит какой-то пакет и что-то от вас просит. Или мышка - пользователь может подвигать мышкой или нажать кнопочку, когда никакое приложение этого не ждет.
В некоторых ситуациях драйверы делают что-то типа callback, то есть драйверы шлют сигналы. На самом деле это не самый удобный способ, но бывает такое. В виндовсе многие типы устройства поддерживают что-то вроде каллбэка. 
Есть еще веселый тип устройств, который мимо нас как-то проехал - таймеры.
Даже когда вам прилетел сигнал, вы все равно обращаетесь к драйверу и говорите, а что случилось то.
Самая крестьянская модель вызова этих функций - те самые блокирующиеся вызовы. Вы хотите что-то прочитать или записать - вы вызываете функцию, под капотом эта функция зовет драйвер, если драйверу нужно время, он блокирует вашу функцию. Это модель, к которой вы привыкли. Приколов с этой моделью много. Один из главных приколов - если вы хотите ждать событий от нескольких устройств. Если вы заблокировались на одном событии, то события от другого вы не поймаете. А если первого события не поступит никогда, все будут очень рады. Есть всякие сетевые сервера с многими клиентами, есть всякие грешные HTTP клиенты, которые тоже чего-то ждут, и соответтсвенно вы это все делаете. Это первый момент. Второй момент - это в некотором роде дорого. Если вы ждете события от устройство, вы должны создавать нить и усыплять её в ожидании события. Если у вас больше нитей, чем ядер на процессоре, то, наверное, у вас что-то не то. Хотя казалось бы, если нити спят на событиях ввода-вывода, то деваться некуда. Второй подход, с которым вы не сталкиваетесь, он у вас спрятан под капотом. Идея примерно такая - драйвер у вас ну точнее да. Зачем нужна это схема с потоками и почему мы не можем просто ждать драйвер. Что нам делать, когда драйвер запросил какую-то операцию на устройство, а он её делает медленно. Драйвер должен усыпить нить. То есть он должен знать, что такое потоки. А есть его просят о чем-то несколько потоков?

Ilya_, [19.03.2025 15:56]
Когда процесс хочет сделать запрос на ввод-вывод, он может ничего не ждать, он может создать структурку, в неё записать к какому устройству запрос, что он хочет от этого устройства, и т.д. А дальше он спрашивает драйвер, в простейшем случае если драйвер ничем не занят, он отдает ему эту структурку. А если драйвер чем-то занят, то процесс делает интересную вещь. У драйвера есть голова очереди и хвост очереди. И процесс ставит запрос в очередь драйверу. Когда драйвер доделывает предыдущий запрос, он смотрит, не пуста ли у него очередь. Если очередь не пуста, драйвер делает следующий запрос. 
В рамках того, что мы проходили, кажется естественным, чтобы драйвер был потоком. Мы можем небольшим числом потоков обрабатывать много запросов. Дальше начинаются более интересные преимущества и недостатки. Вот мы выполнили запрос. Как приложение, которое его делало, об этом узнает? Один из вариантов - сигнал. Но это дорого и неудобно. Тем не менее, в запросе должна быть какая-то информация, во-первых кто посылал запрос, во-вторых а что делать, когда запрос исполнится. 
другой вариант - мы можем связать с запросом что-то типа условной переменной, которая сигналится когда запрос завершился. Если она просигналилась, она должна об этом запоминать, то есть вести себя немножко не так, как в стандарте. 
Вот эта вот модель называется асинхронной модельлю ввода-вывода. Я на самом деле познакомился с ней раньше, чем с синхронной.
Запрос называется QIO - q input/output. Вы даете ему некоторую структуру, и он ставит запрос в очередь.
Также у него есть форма QIOW. Преимущества, которые это нам дает, довольно многообразны. Некоторые из вас изучали C#. Все из вас изучали java, а в java есть select. Если вам надо обрабатывать много запросов от сокетов, у вас есть select. В C#, который похож на джаву, нет select, но там есть именно эта модель асинхронного ввода-вывода, которую я вам рассказываю.
Насколько эта модель хороша, я вам говорить не возьмусь, однако у нас есть задачи и на асинхронный ввод-вывод.

java под капотом не использует тех read и write, которые мы проходили. Она использует неблокирующиеся их формы, поэтому сама джава не засыпает, а просто передает управление другому потоку. 
Так, еще насчет языков. Кто javascript изучал? Никто не признается. Скилл маркетабельный, а язычок довольно прикольный. Там есть syncawait. 
В джаве есть future. Асинхронный ввод-вывод это по сути в чистом виде специализированная future. 
Кстати, тоже забавный наброс. 
Так, коллеги. Я еще раз повторяю просьбу, если у вас замечания по теме лекции то поднимаем руку. Если нет, то какого черта.
Так, я по поводу future делал вам забавное утверждение. Можно ли назвать future гармоническим взаимодействием? Что вообще такое гармоническое взаимодействие?
С: когда мы работаем с копиями данных?
нет, это функциональное программирование.
Каким требованиям должен удовлетворять примитив, чтобы его можно было использовать для гармонического взаимодействия. Вот, зашорились как раз, вы не помните то определение, которое я вам пытался давать, вы помните что-то другое и у вас не получается. Что в нем должно быть атомарным? 
С: API?
нет. Ну, вообще-то да, но нет. У мутекса тоже API атомарный. Синхронизованая передача данных. Можно ли описать future как примитив синхронизованной передачи данных? Да.
Как мы можем имплементировать future на тех posix thread api функциях, которые мы уже проходили. Как на позикс тредах сделать что-то похожее на future? ... Божечки. 
С: pthread_join?
Конечно! pthread_exit и pthread_join
тем не менее, асинхронный ввод-вывод, что я вам уже говорил, самое ценное, что драйвер может не быть нитью. Драйвер может просыпаться по прерываниям и запрашивать исполнение каких-либо операций одной нитью. Хотя может быть проблема с фрагментацией, когда драйверов много, а нити заняты. Как устроена механика softIOQ в линуксе, довольно интересно.

Ilya_, [19.03.2025 15:56]
Почти все системы реального времени делают асинхронный ввод-вывод, это фича, которую они делают.
Большинство устройств, с которыми вы имеете дело, не самостоятельны. А ну а, самое очевидное.. А, ну а, самое простое, что приходит в голову, это на самом деле файловые системы. Открытый файл на файловой системе - это псеводустройство. Но физически устройство одно - это жесткий диск. Запросов много, вам надо их как-то обрабатывать, и на очередях это делается достаточно естественным образом.

Вы до какой-то степени сетевые технологии проходили. Какую модель вы проходите?
OSI
Какой уровень под транспортным? Физический. 
А над транспортным что идет? Приложений, представления, сеансовый. В протоколе SSH сеансовый уровень есть, а представления - не очень-то. Остановился я на чем, там та же история, у вас есть tcp, драйвер dev/tcp, драйвер dev/ip сетевой уровень, и драйвер сетевой карты канальный уровень. На каждом уровне ваши данные разбиваются на какие-то фрагменты и обрастают заголовками и отправляются в сеть. Вся операция у вас превращается в какие-то дискретные пакеты данных, которые обрастают какими-то уровнями протоколов и выкидываются в сеть.

В линуксе эта логика с вводом-выводом на очередях применяется к драйверам дисков - блочным устройствам, и к сетевым устройствам. В линуксе сетевое устройство это не устройство, это не файл. В линуксе у него нет файла в каталоге dev. В солярисе все интереснее, там есть фреймворк для символьных устройств, который называется STREAMS. Но мы так глубоко под капот не заглядываем в практике, поэтому я вам это рассказываю, но оно может не осесть в голове.

Шина USB. Universal serial bus. Вы втыкаете устройства, а они разговаривают по какому-то протоколу между собой, довольно интересному. Они разговаривают с устройством в компьютере, называемом USB контроллером, но по правилоьному оно называется USB hub. Если на USB шине сидит кто-то еще, вам надо делить корневой хаб. Поэтому делают драйвер корневого хаба. Если вам надо с каким-то устройством разговаривать, вы этому драйверу скажите, что хотите с ним говорить. Поэтому у нас часто драйверы общаются не устройствами, а между собой.

Мы с вами пройдем асинхронный ввод-вывод так называемый позиксный. Мы узнаем, как он выглядит для программиста.
Зачем он нужен, в принципе я говорил. Во-первых, у вас есть ряд задач, где вам нужно работать с многими источниками данных и событий. 
Порядок исполнения нитей не гарантирован, а вот запросы ввода-вывода исполняются в том порядке, в котором их ставили в очередь. Задержки работы с устройствами могут быть нетерпимы в приложениях реального времени и всяких других приложениях.

На позиксный ввод-вывод народ ругается в плане производительности и в линуесе есть отдельная панель неблокирующегося ввода вывода, но мы проходим позиксную. Вы их можете отладить под линуксом или даже под макосью и они будут работать.

Ilya_, [19.03.2025 15:56]
Ну и вот, позиксная реализация, это функции, которые можно опознать по нескольким признакам. Они имеют префикс aio_, используют структуру aiocb, и размещены в библиотеке librt.so. С ней мы уже сталкивались, потому что там проме aio живут также семфоры-счетчики. Чтобы пользоваться этой библиотекой, вы должны линковать с ключом -laio. 
В солярисе есть aioread/write, без подчерка, нельзя понять можно только заполнить. Я попытался вам нарисовать что-то похожее на диаграмму.
Приложение делает запрос, потом делает что-то еще, потом синхронизуются. Если вы читаете данные, вы не можете откладывать до бесконечности, поскольку если вы их читаете, вам они, видимо, нужны. С записью вам придется перейти в режим ожидания если у вас кончилась память на эти грешные aiocb структуры.
Когда вам рисовали future возможно она рисовалась точно также.
Запросы aio_read и aio_write похожи. Вам надо завести структуру aiocb, в неё надо положить указатель на данные, на буфер, дескриптор устройства, размер буфера, и при использовании aio_read в принципе всё. 
Там есть несколько интересных полей, дальше мы до них дойдем.
aio_read возвращается более-менее немедленно. Но он может сказать, что что-то в вашей структуре ему не нравится, допустим вы пытаетесь читать из устройства, которое не открыто на чтение. 
запросы чтения читаются не с текущей позиции чтения-записи, они читаются с той позиции, с которой вы сказали. Также, как pread они не передвигают указатель чтения-записи.

Есть в этой структуре еще поле notify. Оно позволяет системе ввода-вывода сказать, когда запрос выполнится, сделай что-нибудь интересное. Что именно, мы позже с вами изучим. Когда вы этот запрос делаете, и читаете или пишете содержимое буфера если запрос еще не завершился, то поведение буфера не определено.

Более интересная форма lio_listio - вы можете собрать пачку запросов и передать её всю в очередь. На listio у нас упражнений отдельных нету, хотя вы можете её использовать в упражнениях на псеводомногопоточные сервера на асинхронном вводе-выводе.

aio suspend, чтобы он мог работать, где-то в запросе есть какой-то семафороподобный примитив, который не является позиксной условной переменной, но без которой работать ничего не будет.

aio return смотрит, чем завершился запрос. Если он завершился еще ничем, он возвращает ошибку. 
Если это read, он возвращает, сколько байт было реально прочитано. Если запрос еще не завершился, он возвращает ошибку. Ошибку можно посмотреть, есть aio error, библиотечная функция, если запрос завершился с ошибкой, она возвращает код такой же как у errno. Тут опять же такая же история как с любой асинхронностью, может быть, пока вы этот aio error звали, запрос уже завершился. aio error тоже можно использовать для проверки, не завершился ли запрос. Однако это может легко выродится в холостой цикл, за который семинаристы вас обязаны карать. 

Пример, довольно развернутый, но поскольку я не очень хорошо вижу черный текст на белом фоне, я не смогу его детально прокомментировать. Вы создаете структуру aiocb, заполняете её поля. В принципе мы такую логику уже проходили когда работали с сокетами. Писанина эта довольно похожа на то, как реально делаются запросы ввода-вывода в VMS, то есть есть структура, вы заполняете её поля и скармливаете её. Мы делаем некоторое издевательство, открываем HTTP соединение, потом читаем, потом делаем HTTP запрос, это для честности. Однако пообщавшись через telnet или netcat с HTTP сервером, вы можете убедиться, что пока вы запрос не отправите,  сервер вам ничего не скажет.

Ilya_, [19.03.2025 15:56]
Заполнив структуру notify вы можете сказать, что кроме suspend вы можете узнавать о завершении запроса другими способами. Все они сводятся к некоторому callback вызову функцию, которую вы смотрите. Как эта функция вызывается зависит от типа notify.
типы нотифай в разных юниксах разные, единственный который есть везде - сигнал. Есть забавная форма aio_thread. Функция позовется в отдельном треде. Правда он будет солярисный, а не позиксный, так что с ним не связываемся. С сигналами тоже много мороки, но они удобны тем, что если ваша программа основная засела в блокирующийся системный вызов, сигнал его прервет и вы событие не пропустите. Есть несколько тем, какой номер сигнала использовать. Теоретически вы можете использовать любой номер сигнала. Но любые могут вам прилетать от других причин. Однако в posix есть свободные сигналы SIGUSR1 и SIGUSR2. Также сигналы с номерами больше то ли 43 то ли 48, не очень помню. Есть еще один странноватый сигнал SIGIO, который на самом деле имеет немного другое применение, но в данной ситуации его можно использовать, поскольку это другое применение с асинхронным вводом-выводом не очень-то совместимо. 
Есть другие примерчики, но я их не комментирую, не потому что вы не можете этим пользоваться, а потому что мы это не проходим. Ответ про сигналы, что они могут прерывать блокирующиеся вызовы. И даже если вы делаете флажок рестарт этому вызову, вы можете прерывать их почти прозрачно, вызов прервется и перезапустится.
Однако когда вы используете сигналы для нотификации, вам мало знать, что завершился какой-то запрос ввода-вывода. Вам надо знать, какой запрос завершился. Значит вам надо сделать странную вещь - обработчик сигналов с гораздо большим числом параметров, чем мы проходили. И если у вас несколько таких сигналов накопится, вы хотите их получить все, чего традиционные сигналы не делают. В юниксе есть надежные сигналы, но с ними есть сложности - весить обработчик надо на них другим способом и посылать тоже их надо другим способом. Чтобы послать такой сигнал надо использовать sigrise метод, и ему надо передать параметры, которые надо передать обработчику. Он не только ставит битик в маске необработанных сигналов, он еще и сигнал помещает в очередь. Сколько будет райзов, столько раз вызовется обработчик. Вы передаете ему параметры. 
Чтобы получить эту информацию, обработчик вам надо вешать через системный вызов sigaction. Это единственный способ повесить обработчик для надежных сигналов. Ему надо поставить в структуре флажок sa_siginfo. И сама структура должна лежать в поле sa_action.
То есть вы во-первых обязаны поставить sa_action, во вторых поставит обработчик в другое поле. Тогда вы имеете надежду получить те параметры, которые этот обработчик применяет. Мы возвращаемся к теме sigaction, тут показываются поля, которые вам надо настроить. Номер сигнала - маска сигнала. Если вы не знаете, что это за поля и зачем они вам нужны, то вы должны их залить нулями. 
Соответственно ну и вот как дальше быть. Один из способов как дальше быть, мы проходили функцию sigpause, которая атомарно размаскирует сигнал и просыпается если сигнал прилетел. Атомарность избавляет нас от ошибки потерянного пробуждения и задерживает вызов обработчика. Если вы хотите использовать нотификацию сигналами, то вы не хотите ожидать большинства запросов.

Если сигнал, который вы ждете, будет замаскирован, то никакая нотификация работать не будет. Веселая тема, которую я не затрагивал в прошлом семестре, поскольку боялся стриггерить вывих мозга. А вывих мозга состоит в том, что когда вы делаете sigset, сигнал блокируется на время работы обработчика. А когда вы делаете sigaction, у вас ставится маска сигналов на время работы обработчика и сигнал можно попросить чтобы он блокировался. Трагизм в чем - если вы уйдете из такого обработчика longjumpом, то с точки зрения runtime вы по-прежнему будете находится в обработчике сигнала. Поэтому есть sigsetjmp и siglongjmp. Хотя на них все равно довольно плохо это делать. Пример, который я написал, использует их, но использует довольно странным образом.

Ilya_, [19.03.2025 15:56]
Ну и вот у меня тут на несколько слайдов записан пример кода. В этом коде я пытаюсь воспроизвести то, как работает типичный драйвер устройства.
слайд - асинхронный ввод на сигналах (main)
Вы создаете такую квази нить, которая активируется в моменты, когда приходит запрос, посылает следующий запрос прозрачно для основной нити. И только когда выкачала все данные, говорит основной нити "просыпайся". То, что оно сделано на sigsetjmp, не очень хорошая идея. Под капотом есть еще одна интересная деталь. Хотя я вам рассказывал, что асинхронный ввод-вывод позволяет избежать создания нитей, в линуксе и в солярисе происходит вызов обработчиков.

Когда у вас много источников событий, как в псевдомногопоточных клиентах на асинхронном вводе-выводе, пример с паузой не очень удачный.

На асинхронный ввод-вывод есть ругань, что он не оптимальный по производительности. 
Однако задачи, которые мы делаем, позволяют вам так сказать погрузиться в проблематику. Хотя там более высокий порог вхождения, вы вынуждены писать довольно много непривычного кода. Но этот код - так называемый boiler plate.
Асинхронный ввод-вывод довольно полезен с одной стороны если вы будете заниматься интернет-вещами и реалтаймом, с другой стороны с высоконагруженными приложениями. 

План лекции у меня исчерпан.