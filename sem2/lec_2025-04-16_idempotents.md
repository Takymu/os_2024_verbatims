
ОСи, Лекция 09.04.2025

*Иртег не успел доесть рулетик до звонка"
Прошу прощения, мкгмм

Мы находимся довольно в забавной ситуации. Потому что предыдущую лекцию читал не я, и мне интересно, что он вам рассказал и на чем он остановился.

Почему сейчас большая часть систем журнальные? Чтобы восстанавливать после смерти сервера, к примеру.

Если операция какая-нибудь началась, но не закончилась.
Это сочетание событий, после которого надо восстанавливать. Но что восстанавливать? Транзакции? 

Мы восстаналиваем консистентность.
Когда у вас заканчивается электричество, садится батарейка, когда вы выдергиваете флешку, не отключив, когда у вас сетевой Access Network и вы доступаетесь к диску через какую-то инфраструктуру, которая может сломаться, у вас структуры данных на диске могут остаться в неконсистентном состоянии.

Какой вид неконсистентности опаснее всего?

Какие есть операции над файлами, которые изменяют его метаданные? Выделение места под файл.

Как хранятся свободные блоки файла? В виде битмапа. Битовой карты. То есть на каждый блок есть битик, если он единица, то битик свободный. Информация о занятых и свободных блоках у вас есть в разных местах и в разных форматах. Самая страшная неконсистентность может быть если вы посчитаете блок одновременно как свободный, так и занятый файлом.

Диски, особенно шпиндельные, делают переупорядочение операций, потому что они оптимизируют движение головок. В результате этого операции могут переставиться, и вы даже вроде как гарантируя, что могут быть только потерянные блоки, получите cross-linked file - два файла имеют несколько общих блоков.
Направление борьбы - файловая система FAT, в котором все хранится в одном месте и изменение метаданных в какой-то степени атомарно. Поэтому FAT страдает довольно мало от отключений питания.

До распространения журнальных ФС, была техника в юниксе.

Три подхода.
Fsck/chkdsk - ставим где-то в заголовке файловой системы флажок, который по английски называется dirty flag. Мы взводим его, когда файловая система монтирована на чтение-запись. 
Ну и вот, dirty flag. Когда мы монтируем ФС и видим, что стоит этот флаг, мы запускаем утилиту chkdsk. Что она делает - нечто очень похожее на сборку мусора mark and skip. Она проходит по всем инодам и строит карту занятых блоков. Все, что останется, она объявляет свободными блоками. Есть приколы, что могут быть хардлинки симлинки. Может быть, что хардлинк создали, а счетчик инодов не обновили. Но страшно наоборот, когда вы имя в каталоге не удалили, а инод стертым не считается. На многих unix есть папочка lost+found, в котором такие потерянные файлы хранятся. Мы проходим по всем объектам и считаем, сколько ссылок на самом деле. С тем, что осталось, решаем, что делать.
Первая проблема - это долго. Примерно пропорционально количеству файлов на диске.
ЭКХЫ!!!
еще у вас может быть проблема что диск большой, и памяти мало. В плохом случае вы даже своп не сможете подключить, потому что у вас файл подкачки на том же самом диске.
Что считается очень большим диском и маленькой памятью, исторически много раз менялось.


Как восстаналивать корневую ФС проще показать наживую. Забавный танец исполняется, в юниксе можно даже глазами наблюдать. Проблема в чем - все утилиты ФС check лежат в корневой файловой системе. Как до них добраться? Монтируем в read-only, тогда её нет риска повредить.
Но все равно это проблема. Первые, кто смог её решить - были разработчиками баз данных.
Вводим понятия транзакции. Транзакция - группа операций, которые либо исполняются все вместе, либо не исполняются вообще.
Главная трагедия - понятие целостности - категория неформализуемая. Единственный, кто может в вашей логике определить критерий целостности и транзакцию, это программист. Если он это сделает неправильно, у вас будут проблемы. А если правильно - то это первый шаг к решению проблемы. Кстати обратите внимание, что логика определения кода, который исполняет транзакцию, очень напоминает критическую секцию.
Если у нас транзакции сериализованы, то исполняются последовательно, то нам только это и надо обеспечить. Но блокировки тут не помогут - выключение питания выключит вам все вместе с блокировками. Журнал - мы выделяем некую дополнительную область, которая должна быть статической. Обычно делают кольцевой журнал фиксированного размера. Бывают решения, когда журнал кладут в другое место, например на более быстрый носитель. Но и с этим вариантов есть способ огрести приколов. Транзакции мы делаем в два этапа. Сначала пишем описание транзакции в журнал, данные не трогаем. Потом убеждаемся, что данные легли на диск. Затем делаем так называемый накат - переносим изменения в рабочие данные. Журналы есть двух типов - rollback и redo. Первые восстанавливает данные, как были, второй позволяет переделать операцию, но может потерять исходное состояние. REdo в какой-то мере логичны для файловых систем. Когда вы делаете redo, вам надо сохранять список операций, когда вы делаете rollback, вы должны сохранять данные.
У вас в файловых системах очень ограниченный набор операций. Их порядка десятка, но не так много. А в базах данных вы можете как транзакцию написать что угодно на полном по Тьюрингу языке. 
Все, что я описал, работает, когда у вас транзакции сериализуются. 
Плохо, когда несколько транзакций могут исполняться параллельно. Тут начинается веселуха, которую вы пообсуждаете с Мигинским.

Выглядит как грубый наброс. Я не так давно помогал своему коллеге собеседовать кандидатов на должность locus notes администратора. Обычно если человек отвечает что такое журнал транзакций в locus notes, то он и на все остальное нормально отвечает. А если на этот вопрос не отвечает, то и в остальном у него в мозгах полная разруха.

У нас нет упражнений на это, да и сейчас мало кто пишет нормальную обработку транзакций. Вы просто берете sqlite какой-нибудь и делаете. Тем не менее, когда что-то идет не так с этими хранилищами, вам придется разбираться.

Идемпотентная операция и сама категория идемпотентности имеет смысл только для операций, имеющих побочный эффект. Если вы сделаете идемпотентную операцию много раз, побочный эффект будет таким же, как если бы вы её сделали один раз. Например очевидно, что присваивание переменной целочисленного значения десять, это идемпотентная операция. А увеличение значения на единицу - не идемпотентная. Если у вас транзакция представляет из себя последовательность идемпотентных операций, то вы можете просто накатить её всю заново при восстановлении.
Если последняя запись в журнале это SYNC - все хорошо. Если у вас нет в журнале не SYNC, не COMMIT, то мы должны выкинуть транзакцию. Если у вас в журнале есть COMMIT, но нет SYNC, то мы их все синкаем.

В общем-то действительно я думаю никто из вас не видел check во всей его мощи и красоте.

Можно увидеть ситуации, когда чекдиску кажется, что что-то не то и он делает фалбек на полный чек.

Ну и вот, преимущества. Во-первых у вас фиксированное время восстановления. Во-вторых, вы все изменения пишете два раза, то есть казалось бы производительность должна падать. Но неожиданный плюс в том, что можно гораздо агрессивнее кэшировать.


Минусы
операций записи вообще довольно много, а это печально для SSD, у которых ограниченное кол-во циклов чтения-записи.

Когда начиналось внедрение журнальных файловых систем, начинались ужасы. Типовая ситуация до этого была - упала винда в синий экран, загружается тоже в синий экран. Более-менее прекратилось это примерно так.. Ну, mtfs надо отсчитывать с 91 года, прекратилось это году в 98-99. В этот период как раз внедрение mt шло довольно удручающими темпами, потом они это починили.
Была волна так называемых гибридных файловых систем. Есть такая система EX3. Вся структура файловой системы EX2 осталась такая же, но сверху добавился журнал. До середины десятых это была рабочая лошадка во всех линуксах, серверах и рабочих станциях. Почему народ на это покупался? Драйвер отработанный, ошибок в нем нет.

В транзакцию включаются только данные файловой системы, так называемые метаданные. На это есть две причины. Во-первых чтобы сделать транзакцию, надо понимать её границу. В API позиксном для работы с файлами нет операций, которые выделяют начало и конец транзакции. А если мы не можем определять начало и конец транзакции, мы не можем гарантировать, что данные целостны. 
Большинство серверов баз данных делают свои журналы, из юзерленда вставляют системный вызов fsync. Он дожидается, пока все будет записано на диск. Вы можете его использовать для выполнения вот этой фазы. Вы это делаете и все вроде бы решаемо. Есть некоторые приколы. Самый интересный из приколов - это резервное копирование. Представим себе, что у вас рабоатет монитор транзакций, и вам надо его забекапить. Вы получаете состояние журнала транзакций на один момент, а состояние самих данных на другой. Что произойдет если вы попытаетесь накатить такой журнал? Катастрофа. То, что происходило при падении mtfs. Данные превращаются в фарш. 

Есть такая фишка, в виндовсе она сделана на уровне файловой системы. Называется она снапшотами. Идея довольно проста и перекрывается знакомым нам словом copy-on-write. Делаем снапшот, и у нас появляется вторая файловая система, которая отражает состояние первой. Как это сделать? Просто все данные, которые вы модифицируете, где-то сохранять, их начальное состояние. NTFS когда делает такие снимки, хранит их в свободном месте на том же томе. И пока у вас свободное место не кончится, вы можете иметь мгновенный снимок, то есть состояние ФС на момент снимка. И вы можете его забекапить. Большинство утилит бэкапа виндовс как раз это и делают. Но в этом есть некоторая костыльность. Это дорого, это сажает производительность.


Второе направление улучшение - обеспечение целостности. ФС ISO 9660 Хаверко вам не рассказывал. Просто CD в домашних условиях записать нельзя было. Потом появились CD-Rom, на которых можно было только дописывать. Потом они появились со стиранием. В классический CD-rom вы можете писать, но запись необратима. Была такая утилита, mkisofs, которая создает такой здоровенный файл, которые вы до сих пор можете видеть, это файлы с расширением iso. Идея как их использовать возникла и её довольно рано реализовали. Возможность дописывать на существующий rom диск была придумана. Вам Хаверко рассказывал про ISO 11 и унитарные архивы? Нет. Плохо. В самых простых файловых системах файлы лежат подряд и занимают место на диске. isofs устроена таким же образом, как большой архив. Все файлы лежат подряд, друг за другом. А теперь загадка, мы хотим переписать какой-то файл. Во-первых у нас проблема с тем, что у него длина может поменяться и нам надо искать новое место. Но теперь надо проапдейтить родительский каталог. И его мы не можем перезаписать, нам остается только записать его заново. Как раз идея, которая была реализована в cd romах, она называется мультисессионный диск, и в нем зарезервировано место под 256 корневых каталогов. И если вы поддерживаете мультисессионные диски, вы должны брать последний. Те файлы, которые остались в старой сессии, не меняются и лежат на тех же местах. Идея немножко расточительная в плане места. Вы сохраняете старые данные, новые данные пишете и потом меняете корневой заголовок, который на них на всех указывает. Бонус этой хрени, что если у вас во время этой записи что-то пойдет не так, то старые-то данные у вас останутся. Это к вопросу о консистентности. 

log-структуред запись использует тот же подход записи на диск в штуке, которая ведет себя как нормальная файловая система. 

У вас есть состояние файловой системы на какой-то момент времнеи.

Корневой инод содержит какие-то данные и дерево блоков, которые принадлежат этому объекту. 

я не могу больше писать в этой духоте.

Что-то там про иноды про какую-то технологию запатентованную какой-то компании, какие-то битмапы хренапы пупупу