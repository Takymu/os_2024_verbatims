ОСи, Лекция 19.02.2025. exit и управление нитями.

В старой реализации линукса exit завершала нить.
Если вы не завершаете весь процесс, то вы можете дождаться конкретной нити вызовом
pthread_join. Он похож на wait, главное отличие его от wait в том, что wait ждет только родителей. pthread_join может ждать любую другую нить. Две нити могут ждать третью В таком случае при её завершении одна из нитей получит код возврата, а другая получить ошибку. pthread_join возвращает код возврата, который вернула завершившаяся нить. Джоин на себя возвращает EDEADLK.
Почему-то из-за какой-то неосторожной фразе в методичке или мане народ меня доканывал вопросом, когда освобождаются ресурсы нити. Когда возвращается join, все ресурсы освобождены. Однако это не означает, что это он их освобождает. TLD уже уничтожены к моменту возврата из join. TLD - thread local data, позже обсудим. 
Если вы используете дждоин, вы сначала передаете нити блок параметров, ждете эту нить при помощи джоин и тут возникает проблема владения. Та нить, которая делает джоин, не знает, как освобождать блок параметров. 
Вы с нитью можете сделать еще одну странную операцию - detach. Она означает, что нить нельзя после этого будет джоинить. И её ресурсы будут освобождаться в тот момент, когда она завершится, и код её возврата узнать будет невозможно. Когда вы передаете параметры нити, вы уже должны решить, будет она детачт или не детачт. detach не имеет аналогов среди процессов. Дальше интересная семантика pthread_cancel - вы можете сказать нити "прекратись". И что произойдет, кстати может ничего не произойти. В джаве сделано красивее - в джаве вы можете кинуть нити исключение в саму нить. Его вы можете поймать и даже нить не завершать. У нити есть два ортогональных атрибута - cancel_state и cancel_type. state - вы можете запретить себя cancelить. Если вы позовете cancel, когда будет cancel_state disabled, то когда вы его обратно включите, вам тут же этот cancel и прилетит.
cancel type может быть deffered или async.
В режиме deffered (по умолчанию) cancel запрос обрабатывается только в специальных точках - cancellation points. Есть функция test_cancel - такая точка. Да и довольно длинная простыня функций являются cancellation_pointами. Это почти все блокирующиеся операции. Cancel срабатывает только в этих функциях или в функциях, которые их зовут. Так работает deffered cancel. Почему это хорошо? Я вам столько всего рассказывал про критические секции, что вы должны понимать, если прервать ваш код в неожиданный момент, не позволив вам ничего сделать, вы понимаете, что это ничем хорошим не закончится. А тут вы знаете исчерпывающий список точек, в которых у вас может этот cancel произойти. Нить сама просматривает cancel флаг, причем именно в дискретные моменты времени.
async cancel type - более интересное поведение. Нить с ним может поймать cancel когда угодно. В солярисе это работает так, что когда вы зовете async cancel, возникает специальный сигнал, который сначала нити ставит флажок, что её хотят заканцелить, а потом отправляют сигнал. В асинхронном обработчике этого сигнала есть test_cancel. Понятно, что такое cancel опасен. И большинство алгоритмов, включая большинство библиотек, он поставит колом. В том числе если вы заканцелите функцию, которая сидит в маллоке, вы можете поломать malloc для всех нитей. У функций в манах есть атрибут async_cancel state. Большая часть библиотеки стандартной не является async_cancel state. Если вы включаете асинхронный cancel, вы обязаны отказаться практически от всей стандартной библиотеки языка си. Использование этого async cancel для нас непосильна.
Список точек cancellation приведена в мане cancellation.

pthread_testcancel - чистая точка cancel, которую вы можете позвать когда считаете нужным. Рассуждая про консистентность данных, вам недостаточно знать момент, что канцел прилетел, у вас может возникнуть желание что-то сделать в этот момент. Есть функции pthread_cleanup_push/pop. При помощи этих функций вы можете устанавливать обработчики. Они вешаются в стековом порядке. Эти функции - на самом деле макросы, которые содержат внутри { и }. Если вы их будете использовать не парно и не в соответствии с блочной структурой вашей программы, у вас полезут синтаксические ошибки. Вы должны использовать их только парно, не парно вы их использовать не можете. Вы можете поставить флажок - звать обработчик или нет. Обработчик зовется только при канцеле, но если установлен флажок, то он тоже позовется. 
Ну и тут рассказываются дополнительные всякие слова. Самая страшная трагедия языка Си в том, что в нем нет концепции замыкания. Кто помнит, что такое замыкание в хаскеле? Никто не помнит.
Вот смотрите, в некоторых языках вы можете объявить функцию внутри функции. Когда вы берете указатель на такую функцию, возвращается указатель не на функцию, а на некую хрень, которая называется объектом замыкания. В языках со сборкой мусора это довольно естественно. В языках без сборки мусора довольно сложно.
В Си++ есть понятие замыкания. Но если вы почитаете семантику замыкания в Си++ и попытаетесь понять её по абстрактному описанию, вам гарантирован вывих мозга, если вы попытаетесь понять, как оно реализовано, то вы все поймете.
В Си проблема, если вы хотите передать обработчику локальные переменные. Единственный способ передать ему эти переменные - в блоке параметров. У нас нет на это упражнений.
Еще одна стандартная ошибка молодого разработчика, про которую стоит поговорить, и с которой у меня на семинарах народ свалился в одну яму. Я даже попытаюсь это сделать стоя.
ЭЭээээ, тем не менее, эээээ, вот, так сказать, в моей группе это будет жесткий тест на умение слушатьи понимать лекции. История такая:
В стандарте языка Си написано, что выход из мейна эквивалентен вызову exit. Те из вас, кто с этим экспериментировал, могут обнаружить, что когда у вас завершается мейн, завершаются все нити вашего процесса, потому что они подчинены процессу. Возникаети история, что очень часто вы этого не хотите. Один из способов с этим бороться - в конце мейна поставить джоин на все нити. С другой стороны могут быть нити, созданные не из мейна. Чтобы понять, что делать, надо заглянуть под капот и понять, как эта магия происходит.
Я вам этот момент рассказывал в прошлом семестре и почему-то народ этот рассказ забыл.
Самое интересное-то не в том, как это происходит, а в том, как мейн создается. В стандарте вы увидите довольно туманные слова, гласящие, что вообще-то перед вызовом мейна в вашей программе что-то должно произойти. Например конструкторы статических переменных.
Если вы посмотрите образ процесса после exec, вы увидите, что там не упоминается никакой main, а структура стека похожа на ту, что происходит при вызове функции, но не тождественна ей. Когда вы собираете программу обычным образом, то кроме стандартной библиоетки прилинковывается еще один объектный файл, srt1.o, в котором определен символ _start, который является стартовым вашей прогарммы. У этого символа _start стоят какие-то специальные файлы, которые говорят что-то линкеры. В некоторых книгах, например в Робачевском, которого я пытался рекомендовать, сказано, что _start это функция.
Я призывал некоторых трудящихся подумать, что такое функция в языке Си.
Блок кода, но не любой блок кода. 
ABI определяет, что такое функция?
ABI - уже теплее, но какая его часть описывает, собственно, функции. Соглашение о вызовах. Это довольно большая часть ABI, которая говорит, как надо передавать параметры, в том числе какого типа эти параметры, какого размера эти параметры и так далее. То есть функцией с точки зрения языка Си можно называть кусок кода, которая соответствует соглашению о вызовах сишному. В этом смысле _start не является функцией.

Вот тут тоже момент. На самом деле и подключение стандартной библиотеки и подключение вот этого кода стандартного, который иногда громко называют cruntime, оно выполняет линкером, причем не по своей инициативе. 
gcc - это compiler driver. Это не сам компилятор. Компилятор - программа, которая генерирует машинный или ассемблерный код. 
gcc может, но не обязан запускать компиляторы. И при том он всем командам, которые запускает, передает правильные опции. И именно он говорит линкеру, что ему надо подключить cruntime и стандартную библиотеку языка Си, если вы запускаете стандартную сишную программу. Если для вас это невозможно, например если вы компилируете ядро ОС, вы можете сказать компилятору не подключай мне стандартную библиотеку и cruntime и он не скажет линкеру все это подключать.
Если вы хотите завершить main так, чтобы exit не звался - у вас есть решение, позвать pthread_exit перед выходом из main. Однако ужас в том, что из стандарта это не следует, но если вы пишете под солярис, линукс и макос, оно так и будет работать. Но если вы хотите писать программы, полностью соответствуют стандарту, вам этим приемом пользоваться не следует. Из текста стандарта даже не следует, что вы можете вызывать pthread_exit в мейне.
Снаружи вы можете прибить программу при помощи всяких средств и, собственно, у нас следующая тема именно про это. 

Атрибуты нитей. 
Позикс треды - стандарт, который заточен под кроссплатформенность, и разные платформы кроме своих атрибутов могут добавлять какие-то свои атрибуты нитей.
Если передавать их всех в параметрах - то расширить или сократить список этих атрибутов превращается в какую-то неразрешимую трагедию. Поэтому завели тип pthread_attr_t, в котором вы можете создавать атрибуты нитей. Вам не положено знать, как она устроена, вы можете использовать get/set функции в языке си, которые модифицируют те атрибуты, которые вы понимаете. Соответственно, некоторые из этих атрибутов вы можете поменять потом у живой нити, некоторые вы поменять не можете, а некоторые можете поменять только в одну сторону - если вы сделаете детач, вы потом его отменить не сможете никогда.
pthread_attr_init - функция, заполняющая pthread_attr_t атрибутами по умолчанию.
Есть множество атрибутов
PTHREAD_SCOPE_PROCESS
PTHREAD_CREATE_JOINABLE - вы можете сделать нить детач после старта или сразу сделать детачт на неё. Упражнений у нас на это нет, но нарваться вы на это в принципе можете. 
Еще два атрибута - вы можете указать размер стека для нити и вы можете указать этот стек сами. Рантайм под нити выделяет с запасом, порядка двух мегабайт для 64-битных процессов. Если у вас мало памяти и много нитей, вас это может напрягать, однако мы не проходим ничего, что позволяет определить реальный размер стека.
Вообще, атрибуты нити это такой шаблончик. Вы его задаете и можете менять атрибуты нитей как ходите. Со стеком это не проходит, если вы указываете стек через pthread_attr_t, то когда вы создаете следующую нить, вам надо укзаать другой стек. Там еще есть приоритет, на самом деле про приоритет мы... эта.
А, ну да, то есть SHED_OTHER. Солярис по умолчанию ставит SHED_OTHER, что немножко бессмысленно. У атрибутов есть get/set методы. pthread_attr_[get/set][имя атрибута]
PTHREAD_SCOPE_SYSTEM/PROCESS если у вас есть системные нити, вы можете создавать её bound - привязанной к системной нити. В солярисе бесполезный атрибут.
PTHREAD_CREATE_JOINABLE/DETACHED вы можете захотеть использовать, однако у нас нет упражнений на это. 
Shedpolici - SCHED_FIFO/RR/OTHER - фифо старая концепция реализации многопоточных программ. фифо в чистом виде это переход к кооперативной многозадачности. Дефолтный класс планирования - shed_other. А для управления приоритетами используется prioctl.
Вы можете присоединиться к двум стандартным классам планирования. А, нет, к одному не можете, потому что у вас прав нет, и к другому тоже не можете. В общем, замуровали демоны. У нас еще будет лекция по классам планирования.

Еще у параметров планировщика есть так называемый nice level - чем он больше, тем ниже приоритет. nice - слово имеется в виду как быть хорошим. Как его этот, дед мороз или санта клаус. Быть nice - не требовать много ресурсов, и высокий nice level - это низкий приоритет.
На самом деле презентация достаточно короткая в первую очередь засчет того, что там много отсылок к вещам, которые мы не проходим. 

thread management. 
Есть функция pthread_self, которая возвращает вам объект для вашей текущей нити. Если вы хотите поманипулировать своими приоритетами, вам нужен объект вашей текущей нити. 
pthread_once - у нас на неё нету упражнений, но при делании сложных задач, таких как прокси, она вам может пригодиться. Вы в джаве проходили такую концепцию как синглтон, объект, который существует в единственном экземпляре. 
Есть два подхода
1. создать до создания нитей.
2. ленивая инициализация, сделать когда потребуется.
Сама по себе ленивая инициализация это просто, но что будет если у вас её попытаются сделать сразу две нити? А самое страшное, что будет, например такой сценарий. У вас нить начинает делать pthread_once, эту нить cancelят, объект не создался, но все флажочки, что он создался, уже стоят. Осознали трагедию? pthread_once это штука, которая позволят эту проблему решить.
pthread_once гарантирует, что функция инициализации будет вызвана не больше одного раза, из каких бы нитей вы этот pthread_once не звали.
Если вы попытаетесь сделать что-то иным способом, чем в стандартной библиотеке, вы скорее всего сделаете это неправильно. А если вы делаете это тем же способом, что и в стандартной библиотеке, то почему бы вам не позвать библиотеку?

shed_yield - нить, которая сейчас running, может уступить управление другим runnable нитям. Аналог task_switch из прошлого семестра.
Вчера я посидел на лекции Власова, где он рассказывал вам про функциональные и нефункциональные требования.
Если вы хотите точно проверить, чтобы переключились нити на данный момент, вы можете вставить yield в код и посмотреть. То есть в целях отладки. Утверждение - если функциональность вашей программы меняется от вставки shed_yield, то у вас неправильная программа.
Вы можете использовать shed_yield для ускорения времени реакции. 
По сути это такой элемент кооперативной многозадачности, обратите внимание, что он не стандартный, то есть в позиксе это не требуется. Также вам никто не гарантирует, что мы в результате shed_yield переключимся на нить того же процесса.

Еще одна концепция - thread specific data.
Без неё мы не поймем, как делаются thread_safe функции. Проходили такое в джаве? Нет еще, возможно, кстати, и не будете. У нас нет упражнений на эту механику.
Локальные переменные в ваших программах размещаются в стеке и принадлежат этой нити. Статические и глобальные перменные не принадлежат никакой нити, они по определению разделяемые. Вы хотите создать объект, у которого время жизни дольше, но который отдельно создается для нити.
pthread_key_create - вы создаете ключ и specific data
pthread_key_delete - удаляет ключ и значение
pthread_setspecific - по ключу устанавливает значение
pthread_getspecific - возвращает значение ключа для вашей нити.
setspecific достаточно простые, вы можете передать в неё какой-то параметр, значение, это может быть указатель типа void*. Если оно выделено mallocом, вопрос зачем вам delete и деструктор, тема довольно больная.
вы ключу можете присоединять что угодно, но это что угодно будет свое для каждой нити.
В чем отличие от маллок? Молочный объект вам доступен только пока у вас есть на него указатель. Как только вы теряете указатель, вы его не достучитесь. В статической переменной вы его хранить не можете, поскольку он будет общий для всех нитей. В локальных переменных вы хранить не можете, поскольку как только вы выйдете из блока, они исчезнут.
ключ глобальный, он разделяемый, поэтому вы можете использовать его и привязывать к нему разные значения для разных нитей. Если вы из нитей хотите обращаться к чужим значениям, вам нужна статическая переменная.
Весь смысл thread specific data - что вы локально можете до них добраться из вашей нити и никто кроме вашей нити до них добраться не сможете.
Есть программа prstat - утилита, которая показывает процессы. Вы можете добавить ключик -L, это аналог топа. Вы говорите -l и видите нити процесса и видите идентификаторы LWP в этой.. Ну в зависимости от формата выдачи, идентификаторы LWP могут быть в разных местах. Отладка - тоже больная тема. В общем-то отладчики для многопоточных программ доступны. dbx в солярисе выпилили, рекомендуется пользоваться gdb. gdb отлаживает по принципу stop world, то есть когда любая нить приходит на breakpoint, у вас останавливаются все нити процесса.
Два основных занятия, которыми вы будете заниматься профессионально - изучение чего-то и отладка. Писанием кода вы будете заниматься довольно мало. Если вы не умеете отлаживать, вы бесполезны. Если строить курс так, чтобы вы вынуждены были пользоваться отладчиком, придется просто всем поставить двойки и все кончится.

Нити и стандартные библиотеки Unix.
Без того, что я сейчас расскажу, вы не можете никакими библиотечными функциями пользоваться
Стандартная библиотека языка Си разрабатывалась в начале восьмидесятых и многое в ней по соображениям совместимости поменять невозможно.
Есть функции, которые вполне могут быть thread_safe, есть функции, которые ни с какой стороны как на них не смотреть thread_safe быть не может. 
Функция не может быть однопоточная или многопоточная. Чистая функция, которая не имеет побочных эффектов, гарантированно является thread_safe. Однако большая часть этих вызовов библиотеки thread safe не является. Вот мы проходили в прошлом сезоне, как перемещать указатель чтения/записи. Представим, что у нас есть две нити, которые это пытаются делать. Одна нить читает, вторая перемещает. Что вы прочитаете - вопрос хороший. И dup тут не поможет.
Опять же по семантике, например malloc, который обращается к каким-то глобальным кучам. 
Стандартная библиотека пользуется не теми семафорами и мутексами, которые мы будем проходить.
Опять же интересные фактики, что происходит с сигналами и что происходит при форке с вашими нитями, без этого вы не сможете ничего понять.
Итак, fork.
Операция вроде сама по себе thread safe, однако если вдуматься, что она делает, становится все сложно.
При вызове fork вся память делается copy on write и начинает исполняться с того же места. А теперь представим, что в процессе были другие нити.
Если бы нити копировались, представим, что fork вызвался, а нити эти про это ни сном ни духом. Ничего хорошего.
Поэтому в форке форк делает только ту нить, которая позвала fork. Остальные нити не завершаются, они находятся в некоем специальном состоянии, на самом деле вопрос, можно ли их там заканцелить. Это называется fork one. Опять же, удаление нити это освобождение памяти, и при форке оно не происходит. Это источник граблей.
Если вы сделаете форк и более-менее сразу позовете exec, то у вас все произойдет более-менее естественным образом. Вас ждет еще одно разочарование, смотрите.
Форкается одна нить, остальные принудительно останавливаются. А если одна из них сидела в маллоке? На входе в маллок должна стоять блокировка, и нить эту блокировку захватила. И нить пришла в состояние, из которого никогда не выйдет. И вы теперь не можете пользоваться маллоком.
В секции мана attributes появился специальный атрибут fork-safe. Если он есть, вы можете пользоваться этой функцией после форка в многопоточной программе. Как это достигается? На самом деле это достигается довольно большой кровью, которую разработчики стандартной библиотеки потратили. Есть такая странная функция pthread_atfork. Есть у неё три хука, один зовется в родителе перед форком, и два зовутся в родителе и потомке после форка. Это и есть та магия, которая позволяет стандартной библиотеке обеспечить fork safe для большинства функций с блокировками внутри. 
Делается очень просто но на самом деле, хотя на самом деле тоже просто.
Стандартная библиотека берет и захватывает при блокировке все блокировки, которые может использовать библиотека. И все. И дальше зовется форк. Дальше и в родителе и в потоке просто все блокировки освобождаются.
Проблема, которую я описал, с маллоком, возникает, когда мы зашли в форк, удерживая блокировки. А так мы все блокировки захватили. При этом форк становится дорогой операцией, вам надо сделать кучу магических телодвижений, которые по сути не нужны. И причем не нужны даже в однопоточной программе. То есть вы платите за многопоточность даже когда вы её не используете. Вопреки тому, что Страуструп и другие про философию юникса писали.

Ну и вот, что еще. 
Я скажу два основных факта.
1. Если сигналы это события, обращенные к процессу, а не потокам. Ну и вот, сигнал в многопоточной программе, на самом деле, для того чтобы понять, как они работают, надо ввести термин, сигналы делятся на синхронные и асинхронные. Синхронные сигналы привязаны к определенной точке вашего кода. Если вы поделили на ноль, вам прилетает SIGFPE. Они прилетают в той нити, которой они стригеррились. Асинхронные - все остальные, сигналы, которые пришли в ваш процесс извне. SIGINT, SIGALARM и все прочее. Асинхронные сигналы прилетают любой нити. В том числе могут прилететь любой заблокированной нити, потому что почти все блокирующиеся операции прерываются сигналом.
Когда вы делаете обработчик сигнала, вы весите его глобально, нельзя его повесить отдельно для каждой нити.
Вторая вещь, все-таки вам нужны средства контролировать, какие сигналы в какие нити вам будут прилетать. Обычно это делается так, что у процесса есть, что, так ну ладно, наверное на этом мы остановимся.
