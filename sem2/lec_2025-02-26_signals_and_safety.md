ОСи, лекция 26.02.2025

Чтобы один и тот же сигнал обрабатывался в разных нитях разными обработчиками вам надо делать довольно сложную писанину, которая определенные ограничения на вас наклаыдвает.

Сигналы и потоки. Сигналы делятся на синхронные и асинхронные. Синхронные сигналы возникают при исполнении определенного кода, асинхронные - по внешним признакам.

Сигналы в многопоточной программе - это проблема. И у нас есть на них упраженине. Как минимум одно, вам надо делать этот грешный подсчет числа Пи пока не надоест. Это попытка ввести вас в концепцию, которая очень важна и которая называется graceful shutdown.

Как управлять масками? signal и sigset. Первое, что мы сказали, сигналы sigset и sigaction устанавливают обработчик на весь процесс. Однако есть операции с сигналами, которые вы можете использовать. 

Поскольку мы уже выяснили, что большинство функций стандартной библиотеки в многопоточных программах вынуждены использовать блокировки. На самом деле они используют не те мутексы, они используют внутрибиблиотечный lock. Если вы зовете обработчик сигнала, а какая-то из функций держит какой-то лок, а в обработчике сигнала вы зовете функцию, которая тот же лок использует.

Если вы зовете в основной нити printf, а в нити, которая обрабатывает сигнал, вы зовете putchar или что-то в таком роде, то если это будут разные нити, ничего сильно страшного не будет, а если это будет одна нить, то вы получите дедлок. Обработчик зовется в какой-то из имеющихся нитей, но сам он нитью не является. Причем окно, в которое вы поймаете дедлок, довольно узкое. 

Я буду просматривать принятый семинаристами код, и карать их, а косвенно может и вас. 

Есть функции, которые не держат никаких локов внутри. И функции, которые не держат внутри никаких локов и как-то решают проблему этих локов, у них в мане есть секция под названием Async-Signal-Safe. Важны все три слова. Это означает, что эту функцию можно звать из обработчиков сигналов. Это тоже пример истории, когда вы платите за то, чем не пользуетесь. Даже в однопоточной программе вы не можете звать из обработчиков не Async-Signal-Safe функции. Однако какой-нибудь ИИ вам может посоветовать код, который это делает, и если он это посоветует, вас ждет веселье. На этот атрибут надо обращать внимание, и это сильно ограничивает то, что вы можете написать в обработчике сигнала.

Если вы выходите из обработчика сигнала лонгджампом, то все, что вы делаете дальше, должно тоже быть Async-Signal-Safe. Осознаете ужас? Потому что вы прервали этим обработчиком какую-нибудь функцию, которая могла не быть Async-Signal-Safe.

Мы хотим не только изучать как писать многопоточные программы, но и изучать, как без этого обойтись. 

Есть забавная атрибута, называется pthread_sigmask. Это маска сигналов, отдельная для каждой нити, а есть для процесса.
Сначала используется маска сигналов процесса, а потом маска сигналов нити. 
Что такое вообще маска?
Если сигнал замаскирован, он не доставляется, но как только он размаскируется, он вам прилетит. То есть маска не игнорирует сигналы, а задерживает их. И если у вас сигнал замаскирован в одних нитях, а не в других, то система ищет, в какой нити он не замаскирован. На уровне процесса система задерживает сигналы, а на уровне нитей ищет нить.

Рекомендуется использовать это как запрет прерывания - не доставлять сигнал, если вы не хотите его доставлять. Операции над sigprocmask полностью аналогичны процессной маске.

Маска сигналов по умолчанию наследуется от родительской нити. 

И вот следующее чего мы хотим изучать - sigsetops. Это функции или макросы над масками сигналов. Не все теоретико-множественные операции.

Рекомендуется маску сигналов использовать как непрозрачный тип и пользоваться только этими макросами для манипуляций с ней.

Ну и вот соответственно а вот ну и вот.

Одна вещь, которую я забыл написать, pthread_kill, которая посылает сигнал конкретной нити. Вы можете переслать внутри процесса сигнал конкретной нити. Этим можно пользоваться, чтобы вызвать обработчик в конкретной нити.

И вот, функции, которые можно звать в многопоточных прогарммах. Есть такой термин - thread safe. Он контролируется несколькими атрибутами - MT Safe, Async Cancel Safe, Async Signal Safe, и просто Safe.

Safe - можем вызывать функцию в многопоточной программе, но, возможно, она не оптимизирована для многопоточности. Пример - старые версии malloc.

MT-Safe - функция, насколько возможно оптимизированная для многопоточной среде. Локи, в отличие от предыдущего уровня, держатся минимальное время, используется тонкая блокировка. Coarse Locking и Fine Locking - грубая и тонкая блокировки. Тонкая блокировка - палка о двух концах. Опирается на аппаратные примитивы атомарности, они чистят все кэши и тормозят все процессорные ядра в машине. Правильную блокировку надо не только держать мало времени, но и применять её редко. Серьезное обучение этому вопросу будет у вас в следующем учебном году в курсе "хранение и обработка данных". Там весь этот круг проблем вылезает. У нас есть задачки, на которых некоторые негативные аспекты частых блокировок можно увидеть.

Некоторые функции, например маллок, можно сделать threadsafe путем того, чтобы сделать блокировку на входе и снять блокировку на выходе. 

Ужас в том, что если мы вспомним интерфейс стандартной библиотеки языка Си, вы можете вспомнить целый ряд функций, у которых сама семантика такова, что непонятно, как с ними быть. Мы посмотрим некоторые примеры.

Самый простой пример - есть в стандартной библиотеке функция strtok. Что она делает? Что-то делит как-то там. Поскольку она делит, она возвращает несколько частей. Как по такой сигнатуре можно вернуть несколько строк? 
Звать её с разными указателями каждый раз?
Как вам получить второй токен той же самой строки? 
Трагизм в том, что если вы даете нул, то она должна помнить, какую строку она токенизирует. И в оригинальной библиотеке это делалось путем того, что там просто заводилась статическая переменная. Теперь загадка - что будет с такой функцией, если её позвать в многопоточной программе. Это ужас дизайна. На самом деле вот syncronized блоки вынуждают вас писать критические секции так, что они полностью находятся в пределах одного блока. Проблема strtok в том, что критическая секция в этом случае выходит за пределы функции. 

Я сегодня как раз хотел покарать нескольких трудящихся. Стали мне приносить код, где локи мутексов врапнуты в какую-то функцию, которая работает как обработчик ошибок. Это плохая идея по двум причинам.
1. Компилятор должен знать, где у него зовутся примитивы синхронизации. А вы от него прячите эти функции, которые являются примитивами синхронизации. Это не та ситуация, когда вам надо компилятору усложнять работу.
2. Есть довольно много статических анализаторов, которые проверяют, как вы зовете блокировки. И я не уверен, что никакой из этих анализаторов от такого не сойдет с ума. То есть делать врапперы вокруг блоков это плохая идея. Раньше я вас за это не карал, но сейчас я вас официально предупредил и карать буду.

Во-первых те же самые мутексы не возвращают осмысленных ошибок. И даже если вы используете error-check мутексы, то правильнее их ошибки ассертами проверять, а не ифами. Ведь это ошибки, которые связаны с логикой вашей программы.

pthread_create может у вас зафейлится по внешним причинами, например, когда у вас стоит ограничение по потокам.

strtok_r - одно из решений проблемы. Это стандартная функция, которая введена в позикс. Это так называемся reentrant - реентерабельная форма. И по контракту функции можно догадаться, как эта реентерабельность достигается. Вы даете еще одну переменную, куда strtok может положить вот этот контекст. Это переменная маленькая..

В стандартной библиотеке strtok вместо статической переменной использует thread local data. Вы можете звать strtok для разных нитей, но в разных нитях для одной строки вы его звать не можете. Поведение не совсем стандартное, но оно упрощает портирование старого кода. 

Два подхода - один с реентерабельностью, другой с thread local data. Применяются и для более сложных функции, хотя для них немножко, ээ, плохо.

Ну и вот, пример немножко более, ну это еще не пример. Как выглядит секция атрибутов солярис, в которой написана информация про то, является ли функция thread safe. 

Анекдот в том, что в солярисе и в линуксе у функций может быть разный thread safety. 

Еще одно значение MT-level - MT-Safe with exceptions.
Например, вы хотите в нитях распечатывать сообщение об ошибке. Ипользовать perror вы не можете, потому что звать сообщения errno это не есть хороший тон.

Ну и вот анекдот в том, что strerror возвращает константные строки, и казалось бы, что там может быть не thread safe. А есть исключение, такое, если вы изменяете локаль во время работы этой функции. Строки с ошибками чувствительны к локали. Если вы переключите локаль во время работы strerror, то вас ждет большая веселуха.

Ну и вот, на самом деле тоже всякие функции для типа settime такие приколы есть.

Локаль - это настройки языка, которым вы с человеком общаетесь. Они включают в себя кодировку, язык сообщений, форматы даты, точку или запятую использовать к качестве разделителя и всякие такие мелочи.

Локализация на самом деле, ну вы видели, когда какой-нибудь там офис или браузер выдает вам менюшки по-русски, браузер может серверу говорить, что я хочу странички по-русски, и сервер вам может такую страничку отдать, если она у него есть. И вот, локаль вы можете переключать, и если у вас программа многопоточная, вам надо делать это один раз где-то в начале перед созданием нитей, поскольку довольно много функций на неё нарываются. 

Ну и вот, собственно Unsafe - результаты вызова функции из разных потоков не определены. То есть вам надо звать её в одном потоке, или какими-нибудь семафорами защищать её вызов.

Safe означает, что функцию можно звать из разных потоков, но это может иметь негативные последствия в плане производительности и масштабируемости.

Масштабируемость - насколько ваша программа будет становиться быстрее при увеличении кол-ва процессорных ядер. Если у вас много нитей, но все они большую часть времени проводят в ожидании на каком-то одном семафоре, то никакой масштабируемости нет.

Правило большого пальца - если у вас больше нитей, чем ядер, то вам надо задуматься, зачем вам столько нитей. 

Ну и вот, MT-Safe, функция оптимизирована настолько, насколько Sun или Oracle сочли возможным её оптимизировать в многопоточной среде. 

Я вам когда рассказывал про маллоки, я вам говорил, что маллок использует арены - собственные пулы в каждой нити. Но вы можете над этими пулами надругаться простым путем - делать маллок в одной нити, а free в другой.

Я довольно много сил трачу на то, чтобы вас научить правилам хорошего тона. Но почему-то встречаю сопротивление.

Хороший тон, я вам с разных сторон пытался объяснить. Большая часть хорошего тона - ваш код становится более читаемым и пониманием. Если вы пользуетесь стандартными идиомами, набором правил как писать хорошо, то ваш код выглядит довольно однообразно, лишен индивидуальности, но если новый человек придет к вам в команду, то он его поймет. Иначе у вас проблемы.

Я на самом деле отвлекся и начал говорить про правила хорошего тона. Большая их часть посвящены читаемости и понимаемости кода. Введение многопоточного программирования в учебный план приводит к тому, что мы не можем их заниматься, если вы не знакомы с правилами хорошего тона. Впрочем, многопоточность у вас в учебном плане уже была, хоть и в меньшем объеме.

Ну и вот MT-Safe - интерфейс, который хорошо оптимизирован, насколько это счел возможным разработчик библиотеки.

Async-Signal-Safe подразумевает MT-Safe, хоть и означает лобовой способ делатьфункцию MT-Safe несовместимым с Async-Signal-Safe.

Самое первое, что приходит в голову - чистая функция, не имеющая побочных эффектов. 

В хаскеле есть монады - функции, которые обращаются к внешнему окружению, и с ними происходят всякие чудеса. Поэтому о чистоте всех функций можно забыть. 

Fork Safe мы уже проходили, поэтому я с ним останавливаться не буду.

И вот пример того, когда все, что я вам рассказал, терпит фэйл. 
readdir - пример того, что современных программистов учат так не делать. Что не thread Safe в readdir?
Самый очевидный пример. Возвращаемое значение может быть перезаписано последующими вызовами readdir. Первые реализации readdir всегда возвращали один и тот же указатель. Каждый вызов readdir будет перезаписывать вызов другого readdir. Эту функцию никак не сделать многопоточной.

Однако возможно сделать функцию, которую вы видели в манах, readdir_r. Тут предлагается делать так - вы даете ей место, куда положить этот грешный dirent. Но трагедия в том, что dirent - это структура переменного размера, и вы не знаете, какое место в ней выделать. Однако есть функция pathconf - которая возвращает длину максимального имени файла в файловой системе. 
Сейчас идет тенденция в направлении неконтролируемого роста этих длин имен.
У современных файловых систем длина имени максимальная от четверти КБ до КБ. Иероглифы, японский текст, там каждый иероглиф - это куча байтов. 

И, соответственно, че? И у вас кроме этого pathconf других путей нету, и этот pathconf вы должны звать не один раз на программу, а на каждый readdir отдельно, поскольку длина имени файла - это не атрибут ОС, это атрибут файловой системы. И использование этой штуки вырождается в некую писанину, особенно эта писанина плоха, когда вам приходится использовать маллок. 
И поскольку вы уже раскопали, что в этих папках рthread лежат примеры, в том числе примеры решения задач. И там есть примеры с использованием pathconf, много писанины в которых.

Анекдот в том, что readdir немножко починили. И в солярисе и в линуксе readdir простой. У него эта локация, в которую он возвращает память, привязана к dir* объекту.

Если вам надо несколько разных каталогов, можете использовать это в разных нитях.
Была история в старом потоке, когда студенты могли наблюдать чуть ли не в реальном времени политическую борьбу за тексты стандарта позикс. 

Это ситуация, когда куды крестьянину податься, не очень понятно. Если вы хотите следовать стандарту, у вас получается много писанины.

Второй пример еще хуже. Пример - банальный, этот, наш любимый, как его зовут - write и lseek.
С одной стороны read и write сами по себе thread safe, но в их семантике есть побочный эффект - перемещение указателя чтения-записи. Критическая секция выходит за пределы вашей функции. Если вы делаете одновременно read и lseek, вы просто прочитаете какую-то белеберду. А если вы делаете write и lseek, вы рискуете испортить файл, что куда опаснее. Если вы читали ман, там на той же странице, где есть read и write, там есть pread и pwrite, которые не перемещают указатель чтения-записи, но пишут в ту позицию, в которую вы сказали. Они не делают внутри никакого lseek, но пишут всегда в ту позицию, в которую вы сказали, какой бы эта позиция не была. Если вы используете эту форму, её можно, естественно, использовать только с теми устройствами, которые поддерживают lseek. С терминалами, сокетами и трубами использовать нельзя. Все readы переделывать вы не можете то есть, но некоторые вам надо переделывать.

Сколько у меня осталось времени? Полчаса. Полчаса - это много. Много времени - это всегда хорошо.

thread-safe API мы с вами формально изучили, и одна из главных тем, это мьютексы, и тут на меня выступали.

мутексы. Вот на самом деле тут тоже повод для религиозной войны, по английский они произносятся мьютекс, но давно слова, которые в русском обиходе, приобрели произношение, похожее на английское. 

Я в принципе на эту тему распространялся, мутекс отличается от двоичного семафора тем, что мутекс можно лочить и анлочить в одной нити. По факту можно где угодно, но по стандарту оно так не обязано работать, поэтому такой код будет караться.

Мутексы - такие объекты, у них есть конструктор init, у них есть статический иницилизатор. Сам по себе неинициализированный.

Инициализация мутекса предполагает дополнительные странные констрейнты. Если память, в которой он создан, разделяется между процессами, то его можно использовать для синхронизации не только нитей, но и процессов. Над ним определены операции lock, trylock и destroy. 

Если вы создаете системный ресурс, его надо, наверное, дестроить. Как обычно пользуются мутексами - их дестроить неудобно. Большинство программ этого не делают, и ничего страшного.

mutex init по семантике похож на pthread create.

Когда вы создаете mutex att и создаете по нему несколько мутексов, то уже созданные att не изменяются. Если вы не хотите с этим связываться, вы передаете нулевой указатель. 
Есть статический инициализатор, которй заполняет поля мутекса параметрами по умолчанию.

mutex_lock - основная операция над мутексом, вы говорите, что этот мутекс занят, и все следующие локи из других нитей блокируются. 
Есть также try_lock, если мутекс уже залочен, она возвращает ошибку. Если можно было захватить, он захватывает. Поэтому нельзя его использовать просто для проверки состояния мутекса. 

Мутекс похож на светофор. Он говорит, что вам не следует переходить через дорогу, но он не мешает вам идти через дорогу.

Работа с разделяемыми данными устроена так, что вам надо зайти в несколько критических секций одновременно. Опять рассказ про дедлок.

Рассказ про то, как избегать дедлока, опять. Три способа, захват только одного мутекса, звахат мутексов в определенном порядке, атомарный захват нескольких мутексов, пу-пу-пу-пу. Я понимаю, конечно, что важная информация должна повторяться трижды, но мне уже надоело её трижды записывать.

Финальным способом убедиться, что вы делаете лок и анлок в одном порядке, это код-ревью.

Атомарный захват нескольких мутексов. В позикс тредах нет готовых примитивов атомарного захвата.

При опасности мертвой блокировки бесполезен try-lock.
